import gmpy2
import binascii
import bisect
from datetime import datetime
import math
import mmap
import os
import pdb
import struct
import sys
import threading
import time
import pathlib
import copy

# from crc64iso.crc64iso import crc64
import sys

# from multiprocessing import shared_memory, resource_tracker
from bitstring import BitArray
from functools import reduce

# from numpy import *
import copy
import ctypes

import EfaUtil_v2 as efa_util
from EFA_v2 import *

# profiler switch
enable_profiler = False
if enable_profiler:
    print("\n\n\n!!!!! PROFILER SWITCH IS ON !!!!!\n\n")
    import cProfile
    import pstats
    import io
    from pstats import SortKey

    ob = cProfile.Profile()
    ob.enable()

# ====== select  printing level ======
# efa_util.printLevel(stage_trace)
# ====== Constant Value ======
dram_lat = 100


# ====== helper function ======
def uint8(n):
    return int(n) & 0xFF


def uint16(n):
    return int(n) & 0xFFFF


def uint32(n):
    return int(n) & 0xFFFFFFFF


def uint64(n):
    return int(n) & 0xFFFFFFFFFFFFFFFF


def hash_snappy(value, shift):
    bytes = value
    kMul = 0x1E35A7BD
    return uint32(bytes * kMul) >> shift


def hash_crc(bytes):
    value = bin(bytes)[2:]
    value = value.zfill(32)
    data_in = BitArray(bin=value)

    lfsr_q = BitArray(bin="0001001000110100")
    lfsr_c = BitArray(bin="0000000000000000")
    lfsr_q.reverse()
    data_in.reverse()

    # fmt: off
    lfsr_c[0] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ lfsr_q[5] ^ lfsr_q[6] ^ lfsr_q[7] ^ lfsr_q[8] ^ lfsr_q[9] ^ lfsr_q[10] ^ lfsr_q[11] ^ lfsr_q[14] ^ lfsr_q[15] ^ data_in[0] ^ data_in[1] ^ data_in[2] ^ data_in[3] ^ data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10] ^ data_in[11] ^ data_in[12] ^ data_in[13] ^ data_in[15] ^ data_in[16] ^ data_in[17] ^ data_in[18] ^ data_in[19] ^ data_in[20] ^ data_in[21] ^ data_in[22] ^ data_in[23] ^ data_in[24] ^ data_in[25] ^ data_in[26] ^ data_in[27] ^ data_in[30] ^ data_in[31]
    lfsr_c[1] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ lfsr_q[5] ^ lfsr_q[6] ^ lfsr_q[7] ^ lfsr_q[8] ^ lfsr_q[9] ^ lfsr_q[10] ^ lfsr_q[11] ^ lfsr_q[12] ^ lfsr_q[15] ^ data_in[1] ^ data_in[2] ^ data_in[3] ^ data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10] ^ data_in[11] ^ data_in[12] ^ data_in[13] ^ data_in[14] ^ data_in[16] ^ data_in[17] ^ data_in[18] ^ data_in[19] ^ data_in[20] ^ data_in[21] ^ data_in[22] ^ data_in[23] ^ data_in[24] ^ data_in[25] ^ data_in[26] ^ data_in[27] ^ data_in[28] ^ data_in[31]
    lfsr_c[2] = lfsr_q[0] ^ lfsr_q[12] ^ lfsr_q[13] ^ lfsr_q[14] ^ lfsr_q[15] ^ data_in[0] ^ data_in[1] ^ data_in[14] ^ data_in[16] ^ data_in[28] ^ data_in[29] ^ data_in[30] ^ data_in[31]
    lfsr_c[3] = lfsr_q[1] ^ lfsr_q[13] ^ lfsr_q[14] ^ lfsr_q[15] ^ data_in[1] ^ data_in[2] ^ data_in[15] ^ data_in[17] ^ data_in[29] ^ data_in[30] ^ data_in[31]
    lfsr_c[4] = lfsr_q[0] ^ lfsr_q[2] ^ lfsr_q[14] ^ lfsr_q[15] ^ data_in[2] ^ data_in[3] ^ data_in[16] ^ data_in[18] ^ data_in[30] ^ data_in[31]
    lfsr_c[5] = lfsr_q[1] ^ lfsr_q[3] ^ lfsr_q[15] ^ data_in[3] ^ data_in[4] ^ data_in[17] ^ data_in[19] ^ data_in[31]
    lfsr_c[6] = lfsr_q[2] ^ lfsr_q[4] ^ data_in[4] ^ data_in[5] ^ data_in[18] ^ data_in[20]
    lfsr_c[7] = lfsr_q[3] ^ lfsr_q[5] ^ data_in[5] ^ data_in[6] ^ data_in[19] ^ data_in[21]
    lfsr_c[8] = lfsr_q[4] ^ lfsr_q[6] ^ data_in[6] ^ data_in[7] ^ data_in[20] ^ data_in[22]
    lfsr_c[9] = lfsr_q[5] ^ lfsr_q[7] ^ data_in[7] ^ data_in[8] ^ data_in[21] ^ data_in[23]
    lfsr_c[10] = lfsr_q[6] ^ lfsr_q[8] ^ data_in[8] ^ data_in[9] ^ data_in[22] ^ data_in[24]
    lfsr_c[11] = lfsr_q[7] ^ lfsr_q[9] ^ data_in[9] ^ data_in[10] ^ data_in[23] ^ data_in[25]
    lfsr_c[12] = lfsr_q[8] ^ lfsr_q[10] ^ data_in[10] ^ data_in[11] ^ data_in[24] ^ data_in[26]
    lfsr_c[13] = lfsr_q[9] ^ lfsr_q[11] ^ data_in[11] ^ data_in[12] ^ data_in[25] ^ data_in[27]
    lfsr_c[14] = lfsr_q[10] ^ lfsr_q[12] ^ data_in[12] ^ data_in[13] ^ data_in[26] ^ data_in[28]
    lfsr_c[15] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ lfsr_q[5] ^ lfsr_q[6] ^ lfsr_q[7] ^ lfsr_q[8] ^ lfsr_q[9] ^ lfsr_q[10] ^ lfsr_q[13] ^ lfsr_q[14] ^ lfsr_q[15] ^ data_in[0] ^ data_in[1] ^ data_in[2] ^ data_in[3] ^ data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10] ^ data_in[11] ^ data_in[12] ^ data_in[14] ^ data_in[15] ^ data_in[16] ^ data_in[17] ^ data_in[18] ^ data_in[19] ^ data_in[20] ^ data_in[21] ^ data_in[22] ^ data_in[23] ^ data_in[24] ^ data_in[25] ^ data_in[26] ^ data_in[29] ^ data_in[30] ^ data_in[31]
    # fmt: on

    lfsr_c.reverse()
    res = (lfsr_c >> 4).int

    return res


class CRC64:
    """
    Generated by GPT-4
    """

    POLY64REV = 0xC96C5795D7870F42
    crc64_tab = []

    @classmethod
    def crc64_init_table(cls):
        if not cls.crc64_tab:
            for b in range(256):
                crc = ctypes.c_uint64(b).value
                for _ in range(8):
                    if crc & 1:
                        crc = (crc >> 1) ^ cls.POLY64REV
                    else:
                        crc >>= 1
                cls.crc64_tab.append(ctypes.c_uint64(crc).value)

    @staticmethod
    def crc64_update(crc, byte):
        tbl_idx = (crc ^ byte) & 0xFF
        return (CRC64.crc64_tab[tbl_idx] ^ (crc >> 8)) & 0xFFFFFFFFFFFFFFFF

    @classmethod
    def compute(cls, input_integer):
        cls.crc64_init_table()

        if input_integer < 0:
            input_integer = (1 << 64) + input_integer

        crc = 0xFFFFFFFFFFFFFFFF
        input_bytes = input_integer.to_bytes(8, 'little')

        for b in input_bytes:
            crc = cls.crc64_update(crc, b)

        return crc ^ 0xFFFFFFFFFFFFFFFF


# PATCH FIX TODO
# reusable function to convert unsigned vals to signed
# mask needed to force 64bit arithmetic and retention
# use for immediate and register reads
def sign(val_u, bits):
    safe_val_u = int(str(val_u), 0)
    val_s = safe_val_u
    sign_bit = 1 << (bits - 1)
    mask = (sign_bit << 1) - 1
    if (safe_val_u & sign_bit) > 0:
        xor = (safe_val_u ^ mask) & mask
        val_s = -(xor + 1)
    return val_s

def unsign(val_u, bits):
    safe_val_u = int(str(val_u), 0)
    val_s = safe_val_u
    sign_bit = 1 << (bits - 1)
    mask = (sign_bit << 1) - 1
    return safe_val_u & mask


def bitflips(x):
    first_bit = 1
    input_x = x
    if input_x % 2 == 0:
        first_bit = 0
    bitflips = []
    current_bit = first_bit
    for i in range(1, 64):
        input_x = input_x >> 1
        if ((input_x % 2 == 0) and (current_bit == 1)) or (
            (input_x % 2 == 1) and (current_bit == 0)
        ):
            bitflips.append(i)
            current_bit = input_x % 2
    return first_bit, bitflips


def swizzle(x, first, bitflips):
    val = bin(x)[2:]
    val = val.zfill(64)
    data_in = BitArray(bin=val)
    data_in.reverse()
    swizzle_x = BitArray(length=64)
    swizzle_x.set(0)
    bflen = len(bitflips)
    if bflen < 1:
        print("Error in swizzle mask")
    if first == 1:
        if bflen == 1:
            return x
        # we only use 0->1 transitions for swizzling
        else:
            swizzle_x[0 : bitflips[0]] = data_in[0 : bitflips[0]]
            for i in range(1, bflen, 2):
                lower = bitflips[i - 1]
                upper = 63
                if bflen - 1 != i:
                    upper = bitflips[i + 1]
                middle = bitflips[i]
                swizzle_x[lower : lower + (upper - middle)] = data_in[middle:upper]
                swizzle_x[lower + (upper - middle) : upper] = data_in[lower:middle]
            if bflen % 2 == 1:
                swizzle_x[bitflips[bflen - 1] : 64] = data_in[bitflips[bflen - 1] : 64]
    else:
        # we only use 0->1 transitions for swizzling
        for i in range(0, bflen, 2):
            lower = 0
            upper = 63
            if bflen - 1 != i:
                upper = bitflips[i + 1]
            if i != 0:
                lower = bitflips[i - 1]
            middle = bitflips[i]
            swizzle_x[lower : lower + (upper - middle)] = data_in[middle:upper]
            swizzle_x[lower + (upper - middle) : upper] = data_in[lower:middle]
        if bflen % 2 == 0 and bflen > 1:
            swizzle_x[bitflips[bflen - 1] : 64] = data_in[bitflips[bflen - 1] : 64]
    swizzle_x.reverse()
    return swizzle_x.uint


def createEvent(event_word):
    # self.event_word = (
    #        ((int(self.network_id) << 32) & 0xFFFFFFFF00000000)
    #        | ((int(self.thread_id) << 24) & 0x0FF000000)
    #        | ((int(self.num_operands) << 20) & 0x0F00000)
    #        | (int(self.event_label) & 0x0FFFFF)
    #    )
    elabel = event_word & 0x0FFFFF
    nops = ((event_word & 0x0700000) >> 20) + 2
    tid = (event_word & 0x0FF000000) >> 24
    nwid = (event_word & 0xFFFFFFFF00000000) >> 32
    ev = Event(elabel, nops)
    ev.setnetworkid(nwid)
    ev.setthreadid(tid)
    # thread_mode = (event_word & 0x00800000) >> 23
    return ev  # , thread_mode


# ====== Metric Class ======
class Metric:
    def __init__(self, lane_id):
        self.lane_id = lane_id
        self.tran_bins = dict()
        self.tran_cycle = dict()
        self.tran_label = dict()
        self.ins_per_event = dict()
        self.cycles_per_event = dict()
        self.ins_per_fetch = dict()
        self.ins_per_match = dict()
        self.op_buff_util = []
        self.perf_file = None
        self.cycle = 0
        self.curr_event_scyc = 0
        self.start_ticks = 0
        self.up_lm_read_bytes = 0
        self.up_lm_write_bytes = 0
        self.up_dram_read_bytes = 0
        self.up_dram_write_bytes = 0
        self.up_dram_bytes = 0
        self.num_events = 0
        self.num_threads = 0
        self.total_acts = 0
        self.total_trans = 0
        self.msg_ins = 0
        self.mov_ins = 0
        self.al_ins = 0
        self.branch_ins = 0
        self.op_ins = 0
        self.event_ins = 0
        self.yld_ins = 0
        self.comp_ins = 0
        self.goto_ins = 0
        self.fp_ins = 0
        self.probes = 0
        self.ops_removed = 0
        self.base_cycle = 0
        self.exec_cycles = 0
        self.idle_cycles = 0
        self.last_exec_cycle = 0
        self.total_exec_cycles = 0
        self.cmpswp_ins = 0
        self.cycles_bins = [0] * 500
        self.cycles_bin_step = 200000
        self.event_q_len = 0
        self.event_q_max = 0
        self.event_q_mean = 0.0
        self.event_q_sample_cnt = 0
        self.operand_q_len = 0
        self.operand_q_max = 0
        self.operand_q_mean = 0.0
        self.operand_q_sample_cnt = 0
        self.perf_log_enable = False
        self.user_counters = [0] * 16
        self.period = 500

    def initMetrics(self):
        self.cycle = 0
        self.up_lm_read_bytes = 0
        self.up_lm_write_bytes = 0
        self.up_dram_read_bytes = 0
        self.up_dram_write_bytes = 0
        self.num_events = 0
        self.total_acts = 0
        self.total_trans = 0
        self.msg_ins = 0
        self.mov_ins = 0
        self.al_ins = 0
        self.branch_ins = 0
        self.op_ins = 0
        self.event_ins = 0
        self.yld_ins = 0
        self.comp_ins = 0
        self.goto_ins = 0
        self.probes = 0
        self.ops_removed = 0
        self.base_cycle = 0
        self.total_exec_cycles += self.exec_cycles
        self.exec_cycles = 0
        self.idle_cycles = 0
        self.last_exec_cycle = 0
        self.cmpswp_ins = 0
        self.period = 500

    def Setup(self, perf_file, lane_id, sim):
        self.lane_id = lane_id
        if perf_file is None:
            self.perf_file = None
        elif not sim:
            self.perf_file = perf_file
            open(self.perf_file, "w").close()

    def TranGroupBin(self, tran):
        src = tran.src.state_id
        dst = tran.dst.state_id
        key = (src, dst)
        if key not in self.tran_bins:
            self.tran_bins[key] = 1
        else:
            self.tran_bins[key] += 1

    def TranSetBase(self):
        self.base_cycle = self.cycle

    def TranCycleDelta(self, tran):
        delta = self.cycle - self.base_cycle
        src = tran.src.state_id
        dst = tran.dst.state_id
        key = (src, dst)
        if key not in self.tran_cycle:
            self.tran_cycle[key] = delta
        else:
            self.tran_cycle[key] += delta

    def TranCycleLabelDelta(self, tran):
        delta = self.cycle - self.base_cycle
        src = tran.src.state_id
        dst = tran.dst.state_id
        label = tran.label
        key = (src, label, dst)
        if key not in self.tran_label:
            self.tran_label[key] = delta
        else:
            self.tran_label[key] += delta

    def curTimeStamp(self):
        return self.start_ticks + (self.cycle * self.period)

    def printBins(self):
        for k, v in self.tran_bins.iteritems():
            print("(src_state, dst_state)="),
            print(k, v),
            print("\tcycles:" + str(self.tran_cycle[k]))

    def printLabels(self):
        for k, v in self.tran_label.iteritems():
            print("(src_state, label, dst_state)="),
            print(k),
            print("\tcycles:" + str(v))

    def printDecompressFraction(self):
        sumLiteral0To60 = 0
        sumLiteral61To62 = 0
        sumMatchTag01 = 0
        sumMatchTag10 = 0
        for k, v in self.tran_label.iteritems():
            if k[1] < 61:
                sumLiteral0To60 += v
            elif k[1] < 63:
                sumLiteral61To62 += v
            elif k[1] < 128:
                sumMatchTag01 += v
            else:
                sumMatchTag10 += v
        print("cycle (Literal 0-60):\t" + str(sumLiteral0To60))
        print("cycle (Literal 61-62):\t" + str(sumLiteral61To62))
        print("cycle (Match tag 01):\t" + str(sumMatchTag01))
        print("cycle (Match tag 10):\t" + str(sumMatchTag10))

    def printstats(self):
        # print("Writing File %s" % self.perf_file)
        with open(self.perf_file, "a+") as f:
            f.write("Lane:%d\n" % self.lane_id)
            f.write("Cycles(old):%d\n" % self.cycle)
            f.write("Exec_Cycles:%d\n" % self.exec_cycles)
            f.write("Idle_Cycles:%d\n" % self.idle_cycles)
            f.write("Last_Exec_cycle:%d\n" % self.last_exec_cycle)
            f.write("NumEvents:%d\n" % self.num_events)

            f.write("MessageActions:%d\n" % self.msg_ins)
            f.write("MoveActions:%d\n" % self.mov_ins)
            f.write("ALUActions:%d\n" % self.al_ins)
            f.write("BranchActions:%d\n" % self.branch_ins)
            f.write("OperandActions:%d\n" % self.op_ins)
            f.write("YieldActions:%d\n" % self.yld_ins)
            f.write("CmpswpActions:%d\n" % self.cmpswp_ins)

            f.write("NumofProbes:%d\n" % self.probes)
            f.write("NumOperandsRemoved:%d\n" % self.ops_removed)
            f.write("NumOfActions:%d\n" % self.total_acts)
            f.write("NumOfTransitions:%d\n" % self.total_trans)

            f.write("UpLMReadBytes:%d\n" % self.up_lm_read_bytes)
            f.write("UpLMWriteBytes:%d\n" % self.up_lm_write_bytes)
            f.write("UpDRAMReadBytes:%d\n" % self.up_dram_read_bytes)
            f.write("UpDRAMWriteBytes:%d\n" % self.up_dram_write_bytes)

            f.write("Histograms\n")
            f.write("ActionsPerEvent:")
            for key in sorted(self.ins_per_event):
                f.write(str(key) + ":" + str(self.ins_per_event[key]) + ",")
            f.write("\nCyclesPerEvent:")
            for key in sorted(self.cycles_per_event):
                f.write(str(key) + ":" + str(self.cycles_per_event[key]) + ",")
            f.write("ActionsperFetchEvent:")
            for key in sorted(self.ins_per_fetch):
                f.write(str(key) + ":" + str(self.ins_per_fetch[key]) + ",")
            f.write("ActionsperMatchEvent:")
            for key in sorted(self.ins_per_match):
                f.write(str(key) + ":" + str(self.ins_per_match[key]) + ",")
            f.write("\nCyclebins:")
            for i in range(len(self.cycles_bins)):
                if i * self.cycles_bin_step > self.last_exec_cycle:
                    continue
                f.write(
                    "%d~%d: %s\n"
                    % (
                        i * self.cycles_bin_step,
                        (i + 1) * self.cycles_bin_step,
                        self.cycles_bins[i],
                    )
                )
            f.write("\n")
            f.close()

    def dump_histogram(self, dump_path):
        with open(dump_path, "w") as f:
            for key in sorted(self.ins_per_event):
                f.write(str(key) + "," + str(self.ins_per_event[key]) + "\n")
            f.close()

    def dump_actstats(self, dump_path):
        with open(dump_path, "w") as f:
            temp = 0
            for key in sorted(self.ins_per_event):
                temp += int(key) * int(self.ins_per_event[key])
            f.write("thread-count," + str(self.num_threads) + "\n")
            f.write("instruction-count," + str(temp) + "\n")
            f.write("activation-count," + str(self.num_events) + "\n")
            f.write("dram-bytes," + str(self.up_dram_bytes) + "\n")
            f.close()

    def write_perf_log(
        self,
        network_id,
        updown_id,
        lane_id,
        thread_id,
        event_label,
        payloads=set(),
        msg_id=None,
        msg_fmtstr="",
        msg_reglist=[],
    ):
        if not self.perf_log_enable:
            return

        en_msg = False
        en_cycle = False
        en_action = False
        en_trans = False
        en_queue = False
        en_lm = False
        en_dram = False
        en_sys_dram = False
        for cur_pl in payloads:
            if int(cur_pl) == PerfLogPayload.UD_CYCLE_STATS.value:
                en_cycle = True
            elif int(cur_pl) == PerfLogPayload.UD_ACTION_STATS.value:
                en_action = True
            elif int(cur_pl) == PerfLogPayload.UD_TRANS_STATS.value:
                en_trans = True
            elif int(cur_pl) == PerfLogPayload.UD_QUEUE_STATS.value:
                en_queue = True
            elif int(cur_pl) == PerfLogPayload.UD_LOCAL_MEM_STATS.value:
                en_lm = True
            elif int(cur_pl) == PerfLogPayload.UD_MEM_INTF_STATS.value:
                en_dram = True
            elif int(cur_pl) == PerfLogPayload.SYS_MEM_INTF_STATS.value:
                en_sys_dram = True
        msg_str = ""
        if msg_id is not None:
            en_msg = True
            regval = []
            for reg in msg_reglist:
                regval.append(reg[1])
            msg_str = msg_fmtstr % (tuple(regval))

        # Import perf_logger
        # from _m5.perf_log import writePerfLogUpdownV2
        from _m5.perf_log import writeTsvPerfLogUpdownEvent

        writeTsvPerfLogUpdownEvent(
            network_id,
            thread_id,  # IDs
            event_label,  # event
            # cycles
            self.cycle - self.curr_event_scyc,
            self.total_exec_cycles + self.exec_cycles,
            # message
            (msg_id if isinstance(msg_id, int) else 0xFFFFFFFF),
            msg_str,
        )

        # writePerfLogUpdownV2(
        #    updown_id, lane_id, thread_id,  # IDs
        #    event_base, event_label,  # event
        #    # payloads
        #    en_msg, en_cycle, en_action, en_trans, en_queue, en_lm, en_dram, en_sys_dram,
        #    # message
        #    (msg_id if isinstance(msg_id, int) else 0xFFFFFFFF), msg_str, msg_reglist,
        #    # cycles
        #    self.cycle - self.curr_event_scyc,
        #    # trans
        #    self.total_trans,
        #    # actions
        #    self.total_acts, self.msg_ins, self.mov_ins, self.branch_ins,
        #    self.al_ins, self.yld_ins, self.comp_ins, self.cmpswp_ins,
        #    # queues
        #    self.operand_q_len, self.event_q_len,
        #    # local memory
        #    self.up_lm_read_bytes, self.up_lm_write_bytes,
        # )


# ====== Activation Class is the basic unit of each stage ======
class Activation:
    def __init__(self, state, property):
        self.state = state
        self.property = property


# ====== State's Property Class ======
class Property:
    def __init__(self, p_type, p_value):
        self.p_type = p_type
        self.p_val = p_value


class Paction:
    def __init__(self):
        self.src = None
        self.imm = None
        self.dst = None


class EventQueue:
    def __init__(self, buffSize, metric):
        self.size = buffSize
        self.events = []
        self.top = 0
        self.bottom = 0
        self.metric = metric

    def isEmpty(self):
        return len(self.events) == 0

    def isFull(self):
        return ((self.top - self.bottom) == 1) or (
            (self.bottom == self.size - 1) and (self.top == 0)
        )

    def pushEvent(self, event):
        self.events.append(event)
        self.metric.event_q_len = len(self.events)
        # Update max
        if self.metric.event_q_len > self.metric.event_q_max:
            self.metric.event_q_max = self.metric.event_q_len
        # Update mean
        # use estimation to avoid exceeding max float
        self.metric.event_q_mean = self.metric.event_q_mean + (
            self.metric.event_q_len - self.metric.event_q_mean
        ) / (self.metric.event_q_sample_cnt + 1)
        self.metric.event_q_sample_cnt += 1

    def popEvent(self):
        if len(self.events) == 0:
            printd("EventQ: removing more elements than available?", error)
        event_out = self.events.pop(0)
        self.metric.event_q_len = len(self.events)
        # Update mean
        # use estimation to avoid exceeding max float
        self.metric.event_q_mean = self.metric.event_q_mean + (
            self.metric.event_q_len - self.metric.event_q_mean
        ) / (self.metric.event_q_sample_cnt + 1)
        self.metric.event_q_sample_cnt += 1
        return event_out

    def getOccup(self):
        return len(self.events)


class OpBuffer:
    def __init__(self, buffSize, metric):
        # self.size = buffSize
        self.operands = []
        self.operands_inuse = []
        self.base = 0
        self.last = 0
        self.metric = metric

    def getOp(self, index):
        return self.operands[index]

    def setOp(self, value):
        self.operands.append(value)
        self.metric.operand_q_len = len(self.operands)
        # Update max
        if self.metric.operand_q_len > self.metric.operand_q_max:
            self.metric.operand_q_max = self.metric.operand_q_len
        # Update mean
        # use estimation to avoid exceeding max float
        self.metric.operand_q_mean = self.metric.operand_q_mean + (
            self.metric.operand_q_len - self.metric.operand_q_mean
        ) / (self.metric.operand_q_sample_cnt + 1)
        self.metric.operand_q_sample_cnt += 1

    def clearOp(self, size):
        # self.operands_inuse[self.base+index]=0
        if size <= len(self.operands):
            self.operands = self.operands[size:]
            self.metric.operand_q_len = len(self.operands)
        else:
            self.operands.clear()
            self.metric.operand_q_len = len(self.operands)
            printd("OperandQ: removing more elements than available?", error)
        printd(
            f"Clear {size} operands from operand buffer. New OpBuffer size {len(self.operands)}",
            stage_trace,
        )
        # Update mean
        # use estimation to avoid exceeding max float
        self.metric.operand_q_mean = self.metric.operand_q_mean + (
            self.metric.operand_q_len - self.metric.operand_q_mean
        ) / (self.metric.operand_q_sample_cnt + 1)
        self.metric.operand_q_sample_cnt += 1

    def getSize(self):
        return len(self.operands)


class Thread:
    def __init__(self, tid, opbuff, network_id, ds_base, tmode=0):
        self.tid = tid
        self.network_id = network_id
        self.curr_event = None
        self.continuation = None
        self.thread_mode = (
            tmode  # 0 - LM (no transformation) , 1 - SB (with transformation)
        )
        self.UDPR = [0 for i in range(16)]  # 16 registers for program data
        self.opaddr = 0
        # Only in SB Mode
        self.current_states = []
        self.SBP = 0  # pointer of input stream (used in both LM and SB mode)
        self.SBCR_FSCR = 0
        # the next 5 items are a part of self.SBCR_FSCR (kept as seperate items for the clarity of the program)
        self.MaxSBP = 0
        self.CR_Advance = 8
        self.CR_Issue = 8
        self.rdMode = 0  # 0 - read from LM, 1 - read from SB
        # FSCR content
        self.rmode = 0
        # self.precision = 0  #0-FP64 1-FP32  2-BF16 3-INT32
        self.SBCR_FSCR = (
            (self.MaxSBP & 0x00000000FFFFFFFF)
            | ((self.CR_Issue << 32) & 0x0000000F00000000)
            | (((self.CR_Advance) << 36) & 0x000000F000000000)
            | ((self.rdMode << 40) & 0x0000010000000000)
        )
        # Marzi TODO: Comment this
        self.in_stream = BitArray(
            65536 * 8, endian="little"
        )  # Marzi # size is allocated to the number of bits per each lane since sb is local to each lane
        self.out_stream = self.in_stream  # BitArray('')

        self.ear = [0 for i in range(4)]  # keeping this here for compatibility
        self.ops = opbuff
        # added by Ivy
        self.ds_base = ds_base

    def update(self, curr_event, continuation, thread_mode):
        self.curr_event = curr_event
        self.continuation = continuation
        self.thread_mode = thread_mode

    def set_state(self, current_states, SBP, CR_Advance, CR_Issue):
        self.current_states = current_states
        self.SBP = SBP
        self.CR_Advance = CR_Advance
        self.CR_Issue = CR_Issue

    def SBPB(self):
        return self.SBP >> 3  # Marzi

    def parseIdx(self, dst_reg):
        # print(dst_reg)
        if dst_reg.startswith("UDPR"):
            return int(dst_reg[5:])
        else:
            # print(dst_reg[3:0])
            return int(dst_reg[3:])
        return int(dst_reg[5:])

    # May not be needed for ob buffer
    def parseOffs(self, ob_ident):
        return int(ob_ident[3:])

    def parseEars(self, ears):
        return int(ears[4:])

    def rd_obbuffer(self, ob_ident):
        offs = int(ob_ident[3:])
        printd(f"    rd_register [{ob_ident}]:{self.ops.getOp(offs)}", stage_trace)
        return self.ops.getOp(offs)

    def rd_obbuffer_block(self, ob_ident, size):
        size = int(size / 8)
        ret_data = [0 for x in range(size)]
        offs = self.parseOffs(ob_ident)
        for i in range(size):
            ret_data[i] = self.ops.getOp(offs + i)
        return ret_data

    def rd_ops(self, ob_ident, num_ops):
        size = int(num_ops)
        ret_data = [0 for x in range(size)]
        offs = self.parseOffs(ob_ident)
        for i in range(size):
            ret_data[i] = self.ops.getOp(offs + i)
        return ret_data

    def rd_register(self, reg_ident):
        if reg_ident[0:4] == "UDPR":
            idx = self.parseIdx(reg_ident)
            printd(
                f"    lane {self.network_id} tid {self.tid} rd_register -\t[{reg_ident}]:{self.UDPR[idx]}",
                stage_trace,
            )
            val = sign(self.UDPR[idx], 64)
            return val
        elif reg_ident == "SBP":
            # return self.SBP
            return self.SBP  # Marzi
        elif reg_ident == "NWID" or reg_ident == "LID":  # What should this become
            # printd(f"    lane {self.network_id} tid {self.tid} rd_register -\t[NWID]:{self.network_id}", stage_trace)
            return self.network_id
        elif reg_ident == "SBPB":
            print("this register is no longer supported!")
        elif reg_ident[0:2] == "OB":
            return self.rd_obbuffer(reg_ident)
        elif reg_ident == "EQT":
            return self.curr_event.event_word
        elif reg_ident == "TS":  # broken?
            return self.thread_state
        elif reg_ident == "TID":  # for debug purpose
            return self.tid
        elif reg_ident == "SBCR_FSCR":
            return self.SBCR_FSCR
        elif reg_ident[0] == "X":
            # new register map
            regnum = int(reg_ident[1:])
            if regnum == 0:
                # printd(f"    lane {self.network_id} tid {self.tid} rd_register -\t[X0]:{self.network_id}", stage_trace)
                return self.network_id & 0x00000000FFFFFFFF
            elif regnum == 1:
                printd(
                    f"    lane {self.network_id} tid {self.tid} rd_register -\t[X1]:{self.continuation.event_word}",
                    stage_trace,
                )
                return self.continuation.event_word
            elif regnum == 2:
                printd(
                    f"    lane {self.network_id} tid {self.tid} rd_register -\t[X2]:{self.curr_event.event_word}",
                    stage_trace,
                )
                return self.curr_event.event_word
            elif regnum == 3:
                printd(
                    f"    lane {self.network_id} tid {self.tid} rd_register -\t[X3]:{self.ops.getOp(8)}",
                    stage_trace,
                )
                return self.ops.getOp(8)
                # return self.opaddr
            # elif regnum == 3:
            #    ret_data =[]
            #    for i in range(len(self.ops.operands)):
            #        ret_data.append(self.ops.getOp(i))
            #    return ret_data
            elif regnum == 4:
                return self.SBCR_FSCR
            elif regnum == 5 and self.thread_mode == 1:
                return self.SBP
            # elif regnum == 6 and self.thread_mode == 1:
            #    return self.SBPB()
            # added by Ivy
            elif regnum == 7:
                printd(
                    f"    lane {self.network_id} tid {self.tid} rd_register -\t[X7]:{self.ds_base} hex:{hex(self.ds_base)}",
                    stage_trace,
                )
                return self.ds_base
            elif regnum >= 8 and regnum <= 15:
                opnum = regnum - 8
                return self.ops.getOp(opnum)
            elif regnum >= 16 and regnum <= 31:
                regidx = regnum - 16
                return self.UDPR[regidx]
        else:
            idx = self.parseIdx(reg_ident)
            return self.UDPR[idx]

    def wr_register(self, reg_ident, data):
        printd(
            f"    lane {self.network_id} tid {self.tid} wr_register -\t[{reg_ident}]:{data}",
            stage_trace,
        )
        if reg_ident == "SBP":
            self.SBP = data  # Marzi
        elif reg_ident == "SBPB":
            print("this register is no longer supported!")
        elif reg_ident == "SBCR_FSCR":
            self.SBCR_FSCR = data
            if self.thread_mode == 1:
                self.MaxSBP = data & 0x00000000FFFFFFFF
                self.CR_Issue = (data >> 32) & 0x000000000000000F
                self.CR_Advance = (data >> 36) & 0x000000000000000F
                self.rdMode = (data >> 40) & 0x0000000000000001
                self.rmode = (data >> 56) & 0x0000000000000007
                printd(
                    f"    lane {self.network_id} SBCR_FSCR elements: MaxSBP:{self.MaxSBP}, Issue:{self.CR_Issue}, advance:{self.CR_Advance},rdMode:{self.rdMode},rmode:{self.rmode}]",
                    stage_trace,
                )

        else:
            # printd(f"    lane {self.network_id} wr_register [{reg_ident}]:{data}", stage_trace)
            idx = self.parseIdx(reg_ident)
            self.UDPR[idx] = data

    def wr_ear(self, ear_idx, dw1):
        idx = self.parseEars(ear_idx)
        self.ear[idx] = dw1

    def rd_ear(self, ear_idx):
        idx = self.parseEars(ear_idx)
        return self.ear[idx]

    # Stream Buffer functions

    def getInputStream(self, filename):
        f = open(filename, "rb")
        stream = f.read()
        f.close()

        hex_str = "0x" + binascii.hexlify(stream)
        s = BitArray(hex_str)
        self.in_stream.append(s)

    def getAsciiInputStreamNoCheck(self, stream):
        hex_str = "0x" + binascii.hexlify(stream)
        s = BitArray(hex_str)
        self.in_stream.append(s)

    def initOutputStream(self, sizeInByte):
        hex_str = "0x" + "00" * sizeInByte
        s = BitArray(hex_str)
        self.out_stream.append(s)

    def getInStreamBytes(self):
        return len(self.in_stream) / 8

    def getInStreamBits(self):
        return len(self.in_stream)

    def getOutStreamBytes(self):
        return len(self.out_stream) / 8

    def getOutStreamBits(self):
        return len(self.out_stream)

    def get_instream_bytes(self, byte_addr, size):
        return self.in_stream[byte_addr << 3 : (byte_addr << 3) + size * 8]

    def get_outstream_bytes(self, byte_addr, size):
        data_bytes = self.out_stream[byte_addr << 3 : (byte_addr << 3) + size * 8].bin
        return self.bitsToInt(data_bytes)

    def set_instream_bytes(self, byte_addr, data):
        self.in_stream[byte_addr << 3 : (byte_addr << 3) + 32] = data

    # Print functions
    def printUDPR(self, LEVEL):
        index = 0
        for reg in self.UDPR:
            printd("UDPR_" + str(index) + "=" + str(format(reg, "#010x")) + " ", LEVEL)
            index += 1
        printd("\n", LEVEL)

    def printOB(self, LEVEL):
        index = 0
        for reg in self.ops:
            printd("OB_" + str(index) + "=" + str(format(reg, "#010x")) + " ", LEVEL)
            index += 1
        printd("\n", LEVEL)


class Thread_v1:
    def __init__(self, tid, udpbase):
        self.tid = tid
        self.curr_event = 0
        self.udprbase = udpbase
        self.opbase = 0
        self.ret_tid = None
        self.ret_lane_id = None
        self.ret_event = None
        self.current_states = []
        self.ear = [0 for i in range(4)]
        self.SBP = 0
        self.CR_Advance = 8
        # self.CR_Issue = 32
        self.CR_Issue = 8  # changed by Marziyeh
        self.thread_state = (int(self.tid) & 0x000000FF) << 16
        printd("Thread :%d, UDPBase:%d" % (self.tid, self.udprbase), stage_trace)
        # for now used only in the simulator

    def set_ret(self, ret_tid, ret_lane_id, ret_event):
        printd(
            "Setting Return:Lane:%d, TID:%d, event:%d"
            % (ret_lane_id, ret_tid, ret_event),
            stage_trace,
        )
        self.ret_tid = ret_tid
        self.ret_lane_id = ret_lane_id
        self.ret_event = ret_event
        self.thread_state = (
            ((int(self.ret_lane_id) << 24) & 0xFF000000)
            | ((int(self.tid) << 16) & 0x00FF0000)
            | ((int(self.ret_tid) << 8) & 0x0000FF00)
            | (int(self.ret_event) & 0x000000FF)
        )

    def set_state(self, current_states, SBP, CR_Advance, CR_Issue):
        self.current_states = current_states
        self.SBP = SBP
        self.CR_Advance = CR_Advance
        self.CR_Issue = CR_Issue


class ThreadStateTable:
    def __init__(self, lane_id):
        self.lane_id = lane_id
        self.threads = {x: None for x in range(255)}
        self.freetids = [x for x in range(255)]
        self.usedtids = []

    def getTID(self):
        tid = self.freetids.pop(0)
        self.usedtids.append(tid)
        return tid

    def addThreadtoTST(self, thread):
        self.threads[thread.tid] = thread
        self.usedtids.append(thread.tid)
        if thread.tid in self.freetids:
            self.freetids.remove(thread.tid)

    def remThreadfromTST(self, tid):
        self.threads[tid] = None
        self.usedtids.remove(tid)
        self.freetids.append(tid)

    def threadexists(self, tid):
        if tid in self.usedtids:
            return 1
        else:
            return 0

    def getThread(self, tid):
        return self.threads[tid]


class LM_scratchpad:
    def __init__(self, size):
        self.size = size
        self.DataStore = [0x0] * size

    def initDataStore(self, value):
        for i in range(len(self.DataStore)):
            self.DataStore[i] = value

    def read_word(self, byte_addr):
        wd_data = self.DataStore[byte_addr >> 3]
        if byte_addr + 8 <= self.size:
            wd_next_data = self.DataStore[(byte_addr >> 3) + 1]
        else:
            wd_next_data = 0
        printd(
            "LM Read Word - Byte_offset:%d, Data:%d, Next_data:%d"
            % (byte_addr, wd_data, wd_next_data),
            stage_trace,
        )
        if byte_addr % 8 == 0:
            return wd_data
        elif byte_addr % 8 == 1:
            return (wd_data & 0x00FFFFFFFFFFFFFF) << 8 | (
                wd_next_data & 0xFF00000000000000
            ) >> 56
        elif byte_addr % 8 == 2:
            return (wd_data & 0x0000FFFFFFFFFFFF) << 16 | (
                wd_next_data & 0xFFFF000000000000
            ) >> 48
        elif byte_addr % 8 == 3:
            return (wd_data & 0x000000FFFFFFFFFF) << 24 | (
                wd_next_data & 0xFFFFFF0000000000
            ) >> 40
        elif byte_addr % 8 == 4:
            return (wd_data & 0x00000000FFFFFFFF) << 32 | (
                wd_next_data & 0xFFFFFFFF00000000
            ) >> 32
        elif byte_addr % 8 == 5:
            return (wd_data & 0x0000000000FFFFFF) << 40 | (
                wd_next_data & 0xFFFFFFFFFF000000
            ) >> 24
        elif byte_addr % 8 == 6:
            return (wd_data & 0x000000000000FFFF) << 48 | (
                wd_next_data & 0xFFFFFFFFFFFF0000
            ) >> 16
        else:
            return (wd_data & 0x00000000000000FF) << 56 | (
                wd_next_data & 0xFFFFFFFFFFFF0000
            ) >> 8

    def read_4bytes(self, byte_addr):
        word = self.DataStore[byte_addr >> 3]
        next_word = self.DataStore[(byte_addr >> 3) + 1]
        printd(
            "LM Read 4 bytes - Byte_offset:%d, Data:%d, Next_data:%d"
            % (byte_addr, word, next_word),
            stage_trace,
        )
        if byte_addr % 8 == 0:
            return uint32((word & 0xFFFFFFFF00000000) >> 32)
        elif byte_addr % 8 == 4:
            return uint32((word & 0x00000000FFFFFFFF))
        elif byte_addr % 8 == 1:
            return uint32((word & 0x00FFFFFFFF000000) >> 24)
        elif byte_addr % 8 == 2:
            return uint32((word & 0x0000FFFFFFFF0000) >> 16)
        elif byte_addr % 8 == 3:
            return uint32((word & 0x000000FFFFFFFF00) >> 8)
        elif byte_addr % 8 == 5:
            return uint32(
                (word & 0x0000000000FFFFFF) << 8
                | (next_word & 0xFF00000000000000) >> 56
            )
        elif byte_addr % 8 == 6:
            return uint32(
                (word & 0x000000000000FFFF) << 16
                | (next_word & 0xFFFF000000000000) >> 48
            )
        else:
            return uint32(
                (word & 0x00000000000000FF) << 24
                | (next_word & 0xFFFFFF0000000000) >> 40
            )

    def write_word(self, byte_addr, wd_data):
        printd(
            "LM Write Word - Byte_offset:%d, Data:%d" % (byte_addr, wd_data),
            stage_trace,
        )
        old_wd_data = self.DataStore[byte_addr >> 3]
        next_wd_data = self.DataStore[(byte_addr >> 3) + 1]
        if byte_addr % 8 == 0:
            self.DataStore[byte_addr >> 3] = wd_data
        elif byte_addr % 8 == 1:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFF00000000000000 | (wd_data & 0xFFFFFFFFFFFFFF00) >> 8
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x00FFFFFFFFFFFFFF | (wd_data & 0x00000000000000FF) << 56
            )
        elif byte_addr % 8 == 2:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFFFF000000000000 | (wd_data & 0xFFFFFFFFFFFF0000) >> 16
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x0000FFFFFFFFFFFF | (wd_data & 0x000000000000FFFF) << 48
            )
        elif byte_addr % 8 == 3:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFFFFFF0000000000 | (wd_data & 0xFFFFFFFFFF000000) >> 24
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x000000FFFFFFFFFF | (wd_data & 0x0000000000FFFFFF) << 40
            )
        elif byte_addr % 8 == 4:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFFFFFFFF00000000 | (wd_data & 0xFFFFFFFF00000000) >> 32
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x00000000FFFFFFFF | (wd_data & 0x00000000FFFFFFFF) << 32
            )
        elif byte_addr % 8 == 5:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFFFFFFFFFF000000 | (wd_data & 0xFFFFFF0000000000) >> 40
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x0000000000FFFFFF | (wd_data & 0x000000FFFFFFFFFF) << 24
            )
        elif byte_addr % 8 == 6:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFFFFFFFFFFFF0000 | (wd_data & 0xFFFF000000000000) >> 48
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x000000000000FFFF | (wd_data & 0x0000FFFFFFFFFFFF) << 16
            )
        else:
            self.DataStore[byte_addr >> 3] = (
                old_wd_data & 0xFFFFFFFFFFFFFF00 | (wd_data & 0xFF00000000000000) >> 56
            )
            self.DataStore[(byte_addr >> 3) + 1] = (
                next_wd_data & 0x00000000000000FF | (wd_data & 0x00FFFFFFFFFFFFFF) << 8
            )

    def write_4bytes(self, byte_addr, byte_data):
        printd(
            "LM Write 4 bytes - Byte_offset:%d, Data:%d" % (byte_addr, byte_data),
            stage_trace,
        )
        wd_old_data = self.DataStore[byte_addr >> 3]
        wd_next_data = self.DataStore[(byte_addr >> 3) + 1]
        if byte_addr % 8 == 0:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) << 32 | (
                wd_old_data & 0x00000000FFFFFFFF
            )
        elif byte_addr % 8 == 1:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) << 24 | (
                wd_old_data & 0xFF00000000FFFFFF
            )
        elif byte_addr % 8 == 2:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) << 16 | (
                wd_old_data & 0xFFFF00000000FFFF
            )
        elif byte_addr % 8 == 3:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) << 8 | (
                wd_old_data & 0xFFFFFF00000000FF
            )
        elif byte_addr % 8 == 4:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) | (
                wd_old_data & 0xFFFFFFFF00000000
            )
        elif byte_addr % 8 == 5:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) >> 8 | (
                wd_old_data & 0xFFFFFFFFFF000000
            )
            wd_next_data = (byte_data & 0xFF) << 56 | (
                wd_next_data & 0x00FFFFFFFFFFFFFF
            )
            self.DataStore[(byte_addr >> 3) + 1] = uint64(wd_next_data)
        elif byte_addr % 8 == 6:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) >> 16 | (
                wd_old_data & 0xFFFFFFFFFFFF0000
            )
            wd_next_data = (byte_data & 0xFFFF) << 48 | (
                wd_next_data & 0x0000FFFFFFFFFFFF
            )
            self.DataStore[(byte_addr >> 3) + 1] = uint64(wd_next_data)
        else:
            wd_new_data = (byte_data & 0x00000000FFFFFFFF) >> 24 | (
                wd_old_data & 0xFFFFFFFFFFFFFF00
            )
            wd_next_data = (byte_data & 0xFFFFFF) << 40 | (
                wd_next_data & 0x000000FFFFFFFFFF
            )
            self.DataStore[(byte_addr >> 3) + 1] = uint64(wd_next_data)

        self.DataStore[byte_addr >> 3] = uint64(wd_new_data)

    def read_2bytes(self, byte_addr):
        word = self.DataStore[byte_addr >> 3]
        next_word = self.DataStore[(byte_addr >> 3) + 1]
        printd(
            "LM Read 2 bytes - Byte_offset:%d, Data:%d, Next_data:%d"
            % (byte_addr, word, next_word),
            stage_trace,
        )
        if byte_addr % 8 == 0:
            return uint16((word & 0xFFFF000000000000) >> 48)
        elif byte_addr % 8 == 1:
            return uint16((word & 0x00FFFF0000000000) >> 40)
        elif byte_addr % 8 == 2:
            return uint16((word & 0x0000FFFF00000000) >> 32)
        elif byte_addr % 8 == 3:
            return uint16((word & 0x000000FFFF000000) >> 24)
        elif byte_addr % 8 == 4:
            return uint16((word & 0x00000000FFFF0000) >> 16)
        elif byte_addr % 8 == 5:
            return uint16((word & 0x0000000000FFFF00) >> 8)
        elif byte_addr % 8 == 6:
            return uint16(word & 0x000000000000FFFF)
        else:
            return uint16((word & 0xFF) << 8 | (next_word & 0xFF00000000000000) >> 56)

    def write_2bytes(self, byte_addr, byte_data):
        printd(
            "LM Write 2 bytes - Byte_offset:%d, Data:%d" % (byte_addr, byte_data),
            stage_trace,
        )
        wd_old_data = self.DataStore[byte_addr >> 3]
        wd_next_data = self.DataStore[(byte_addr >> 3) + 1]

        if byte_addr % 8 == 0:
            wd_new_data = (byte_data & 0x000000000000FFFF) << 48 | (
                wd_old_data & 0x0000FFFFFFFFFFFF
            )
        elif byte_addr % 8 == 1:
            wd_new_data = (byte_data & 0x000000000000FFFF) << 40 | (
                wd_old_data & 0xFF0000FFFFFFFFFF
            )
        elif byte_addr % 8 == 2:
            wd_new_data = (byte_data & 0x000000000000FFFF) << 32 | (
                wd_old_data & 0xFFFF0000FFFFFFFF
            )
        elif byte_addr % 8 == 3:
            wd_new_data = (byte_data & 0x000000000000FFFF) << 24 | (
                wd_old_data & 0xFFFFFF0000FFFFFF
            )
        elif byte_addr % 8 == 4:
            wd_new_data = (byte_data & 0x000000000000FFFF) << 16 | (
                wd_old_data & 0xFFFFFFFF0000FFFF
            )
        elif byte_addr % 8 == 5:
            wd_new_data = (byte_data & 0x000000000000FFFF) << 8 | (
                wd_old_data & 0xFFFFFFFFFF0000FF
            )
        elif byte_addr % 8 == 6:
            wd_new_data = (byte_data & 0x000000000000FFFF) | (
                wd_old_data & 0xFFFFFFFFFFFF0000
            )
        else:
            wd_new_data = (byte_data & 0xFFFF) >> 8 | (wd_old_data & 0xFFFFFFFFFFFFFF00)
            wd_next_data = (byte_data & 0xFF) << 56 | (
                wd_next_data & 0x00FFFFFFFFFFFFFF
            )
            self.DataStore[(byte_addr >> 3) + 1] = uint64(wd_next_data)

        self.DataStore[byte_addr >> 3] = uint64(wd_new_data)

    def read_byte(self, byte_addr):
        word = self.DataStore[byte_addr >> 3]
        printd(
            "LM Read 1 byte - Byte_offset:%d, Data:%d" % (byte_addr, word), stage_trace
        )
        if byte_addr % 8 == 0:
            return uint8((word & 0xFF00000000000000) >> 56)
        elif byte_addr % 8 == 1:
            return uint8((word & 0x00FF000000000000) >> 48)
        elif byte_addr % 8 == 2:
            return uint8((word & 0x0000FF0000000000) >> 40)
        elif byte_addr % 8 == 3:
            return uint8((word & 0x000000FF00000000) >> 32)
        elif byte_addr % 8 == 4:
            return uint8((word & 0x00000000FF000000) >> 24)
        elif byte_addr % 8 == 5:
            return uint8((word & 0x0000000000FF0000) >> 16)
        elif byte_addr % 8 == 6:
            return uint8((word & 0x000000000000FF00) >> 8)
        else:
            return uint8(word & 0x00000000000000FF)

    def write_byte(self, byte_addr, byte_data):
        printd(
            "LM Write 1 byte - Byte_offset:%d, Data:%d" % (byte_addr, byte_data),
            stage_trace,
        )
        wd_old_data = self.DataStore[byte_addr >> 3]
        if byte_addr % 8 == 0:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 56 | wd_old_data & 0x00FFFFFFFFFFFFFF
        elif byte_addr % 8 == 1:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 48 | wd_old_data & 0xFF00FFFFFFFFFFFF
        elif byte_addr % 8 == 2:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 40 | wd_old_data & 0xFFFF00FFFFFFFFFF
        elif byte_addr % 8 == 3:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 32 | wd_old_data & 0xFFFFFF00FFFFFFFF
        elif byte_addr % 8 == 4:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 24 | wd_old_data & 0xFFFFFFFF00FFFFFF
        elif byte_addr % 8 == 5:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 16 | wd_old_data & 0xFFFFFFFFFF00FFFF
        elif byte_addr % 8 == 6:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) << 8 | wd_old_data & 0xFFFFFFFFFFFF00FF
        else:
            wd_new_data = (
                byte_data & 0x00000000000000FF
            ) | wd_old_data & 0xFFFFFFFFFFFFFF00

        self.DataStore[byte_addr >> 3] = uint64(wd_new_data)

    def printDataStore(self, start_addr, end_addr, LEVEL):
        for addr in range(start_addr, end_addr, 8):
            data = self.read_word(addr)


class AddrTranslationEngine:
    class PrivateSegEntry:
        def __init__(self, va_base, size, pa_base, rights):
            # [base, size, offset, access_rights]
            self.va_base = va_base
            self.va_bound = va_base + size
            self.offset = pa_base - va_base
            self.rights = rights

        def __str__(self):
            return (
                f"Private Entry: va_base={self.va_base}({hex(self.va_base)}), va_bound={self.va_bound}({hex(self.va_bound)}), "
                + f"pa_base={self.va_base+self.offset}({hex(self.va_base+self.offset)}), rights={self.rights}"
            )

    class GlobalSegEntry:
        def __init__(self, udid, va_base, size, swizzle_mask, pa_base, rights):
            # [base, size, swizzle_mask, physical_base, access_rights]
            self.udid = udid
            self.va_base = va_base
            self.va_bound = va_base + size
            self.swizzle = swizzle_mask
            self.offset = pa_base - va_base
            self.rights = rights

        def __str__(self):
            return (
                f"Global Entry: va_base={hex(self.va_base)}, va_bound={hex(self.va_bound)}, "
                + f"pa_base={hex(self.va_base+self.offset)}, swizzle={self.swizzle}, rights={self.rights}"
            )

        def swizzle(self, va, mask):
            first_bit, flips = bitflips(mask)
            pa = swizzle(va, first_bit, flips)
            return pa

    def __init__(
        self,
        udid,
        scratchpad_base,
        scratchpad_size,
        default_private_seg=None,
        default_global_seg=None,
    ):
        self.udid = udid
        self.sp_segment = (scratchpad_base, scratchpad_base + scratchpad_size)
        self.private_segments = []
        if default_private_seg:
            self.private_segments.append(default_private_seg)
        self.global_segments = []
        if default_global_seg:
            self.global_segments.append(default_global_seg)
        printd(f"Initialize {self}", stage_trace)

    def __str__(self):
        string = f"AddrTranslationEngine on UpDown {self.udid}: \n"
        string += f"  Local Scratchpad: base={hex(self.sp_segment[0])}, bound={hex(self.sp_segment[1])}\n"
        string += "  Private Segments:"
        for seg in self.private_segments:
            string += f"    {seg}\n"
        string += "  Global Segments:"
        for seg in self.global_segments:
            string += f"    {seg}\n"
        return string

    def translate(self, va_addr, length, access_type):
        printd(
            f"UpDown {self.udid} translates addr {va_addr} hex({hex(va_addr)}) with {access_type} access of length {length}.",
            stage_trace,
        )
        for seg in self.private_segments:
            if va_addr >= seg.va_base and (va_addr + length) <= seg.va_bound:
                if access_type in seg.rights:
                    return seg.offset + va_addr
                else:
                    printd(
                        f"Translation error! {'Read' if access_type == 'r' else 'Write'} addr {va_addr} is not permitted.",
                        stage_trace,
                    )
                    exit()
        for seg in self.global_segments:
            if va_addr >= seg.va_base and (va_addr + length) <= seg.va_bound:
                if access_type in seg.rights:
                    return seg.offset + seg.swizzle(va_addr)
                else:
                    printd(
                        f"Translation error! {'Read' if access_type == 'r' else 'Write'} addr {va_addr} is not permitted.",
                        stage_trace,
                    )
                    exit()
        printd(f"Translation error! {va_addr} is an invalid address", stage_trace)
        printd(self, stage_trace)
        exit()

    def validate(self, va_addr, length):
        printd(
            f"UpDown {self.udid} validates addr {va_addr} hex({hex(va_addr)}) with access length {length} on scratchpad.",
            stage_trace,
        )
        if va_addr >= self.sp_segment[0] and (va_addr + length) <= self.sp_segment[1]:
            return True
        else:
            printd(
                f"Valiadation error! Scratchpad addr {hex(va_addr)} is out of bound. \n"
                + f"  Local Scratchpad: base={hex(self.sp_segment[0])}, bound={hex(self.sp_segment[1])}",
                stage_trace,
            )
            exit()

    def insert_local_translation(self, base, size, physical_base, access_rights):
        new_entry = self.PrivateSegEntry(base, size, physical_base, access_rights)
        self.private_segments.append(new_entry)
        printd(
            f"AddrTranslationEngine on UpDown {self.udid}: add private segment {new_entry}",
            stage_trace,
        )

    def insert_global_translation(
        self, base, size, swizzle_mask, physical_base, access_rights
    ):
        new_entry = self.GlobalSegEntry(
            self.udid, base, size, swizzle_mask, physical_base, access_rights
        )
        self.global_segments.append(new_entry)
        printd(
            f"AddrTranslationEngine on UpDown {self.udid}: add global segment {new_entry}",
            stage_trace,
        )


# ====== UDP Processor with multiple lanes =========
class VirtualEngine:
    def __init__(
        self,
        nwid,
        ud_idx,
        num_lanes,
        perf_file,
        sim,
        lmbanksize,
        scratchpad_base,
        tick_freq,
        simout_dir="./",
        perf_log_enable=0,
        perf_log_internal_enable=0,
    ):
        self.sim = sim
        self.perf_file = perf_file
        self.netword_id = nwid
        self.tick_freq = tick_freq
        self.perf_log_internal_enable = False
        if perf_log_internal_enable > 0:
            self.perf_log_internal_enable = True
        self.simout_dir = simout_dir
        self.LM = LM_scratchpad(lmbanksize * num_lanes)
        self.num_lanes = num_lanes
        self.ud_id = ud_idx
        self.send_mm = None
        # added by Ivy
        self.scratchpad_base = scratchpad_base
        private_segment = AddrTranslationEngine.PrivateSegEntry(0, 68719476736, 0, "rw")
        self.mmu = AddrTranslationEngine(
            ud_idx, scratchpad_base, lmbanksize * num_lanes, private_segment
        )
        self.lanes = [
            VirtualEngineLane(
                nwid,
                ud_idx,
                i,
                1000,
                self.LM,
                self.perf_file,
                perf_log_enable,
                self.mmu,
                self,
            )
            for i in range(num_lanes)
        ]

    def __del__(self):
        # dump instruction count stats
        # to support accounting for each lane, each lane should have its own copy of EFA object
        exe_stats_dir = os.path.join(self.simout_dir, "exestats")
        pathlib.Path(exe_stats_dir).mkdir(parents=True, exist_ok=True)
        for i in range(len(self.lanes)):
            self.lanes[i].program.dump_execution_count(
                os.path.join(
                    exe_stats_dir,
                    "insn_exe_stats-ud{}-lane{:02}.tsv".format(self.ud_id, i),
                )
            )
            self.lanes[i].metric.dump_histogram(
                os.path.join(
                    exe_stats_dir,
                    "activation-hist-ud{}-lane{:02}.csv".format(self.ud_id, i),
                )
            )
            self.lanes[i].metric.dump_actstats(
                os.path.join(
                    exe_stats_dir,
                    "activation-stats-ud{}-lane{:02}.csv".format(self.ud_id, i),
                )
            )
        efa_exe_count_total = copy.deepcopy(self.lanes[0].program)
        for i in range(1, len(self.lanes)):
            efa_exe_count_total.combine_execution_count(self.lanes[i].program)
        efa_exe_count_total.dump_execution_count(
            os.path.join(
                exe_stats_dir, "insn_exe_stats-ud{}-total.tsv".format(self.ud_id)
            )
        )
        print("Instruction execution stats dumped to {}".format(exe_stats_dir))

        # for ln in self.lanes:
        #    ln.send_mm.close()
        self.send_mm.close()

        if enable_profiler:
            ob.disable()
            sec = io.StringIO()
            sortby = SortKey.CUMULATIVE
            ps = pstats.Stats(ob, stream=sec).sort_stats(sortby)
            ps.print_stats()
            print(sec.getvalue())

    def printstats(self):
        for ln in self.lanes:
            ln.printstats()

    # API for Simulator/Emulator

    def read_scratch(self, addr, size):
        # printd("read_scratch: addr = %d, data = %d, size = %d" % (addr, self.LM.read_word(addr), size), stage_trace)
        if size == 1:
            return self.LM.read_byte(addr)
        elif size == 2:
            return self.LM.read_2bytes(addr)
        elif size == 4:
            return self.LM.read_4bytes(addr)
        elif size == 8:
            return self.LM.read_word(addr) & 0xFFFFFFFFFFFFFFFF
        else:
            print(f"read_scratch: invalid read size!! size = {size}", flush=True)

    def read_sbuffer(self, addr, size, lane_id):
        printd(
            "Lane:%d Get Out stream buffer%d: size%d" % (lane_id, addr, size),
            stage_trace,
        )
        return self.lanes[lane_id].get_outstream_bytes(addr, size)

    def write_sbuffer(self, addr, data, lane_id):
        printd("Lane:%d write stream buffer%d:%d" % (lane_id, addr, data), stage_trace)
        self.lanes[lane_id].set_instream_bytes(addr, data)

    def write_scratch(self, addr, data):
        printd("write_scratch:%d:%d" % (addr, data), stage_trace)
        self.LM.write_word(addr, data)

    def insert_event(self, lane_id, event):
        self.lanes[lane_id].pushEvent(event)

    def insert_operand(self, lane_id, opval):
        self.lanes[lane_id].pushOp(opval)

    def setup_sim(
        self, efa, simdir, lm_addr_mode, SBPB_BEGIN=0, initID=[0], lane_id=-1
    ):
        efa.fixlabels()
        pname = "./" + simdir + "/ud" + str(self.ud_id) + "_send.txt"
        with open(pname, "w+b") as fd:
            for _ in range(262144 * 2 * 8 + 4):
                val = struct.pack("i", 0)
                fd.write(val)
        fd.close()
        with open(pname, "r+b") as fd:
            self.send_mm = mmap.mmap(
                fd.fileno(), 1048576 * 2 * 8, access=mmap.ACCESS_WRITE, offset=0
            )
            self.send_mm.seek(0)
        for i, l in enumerate(self.lanes):
            l.all_lanes_done = 0
            l.lane_state = "lane_init"
            # printd(f"VirtualEngine::setup_sim() - self.scratchpad_base {self.scratchpad_base}", full_trace)
            l.setup_sim(
                efa,
                simdir,
                lm_addr_mode,
                self.scratchpad_base,
                self.send_mm,
                SBPB_BEGIN=SBPB_BEGIN,
                initID=initID,
            )

    def executeEFA_simAPI(self, lane_id, start_timestamp):
        total_num_sends = 0
        return_tuples = self.lanes[lane_id].executeEFAlane_sim(start_timestamp)
        return return_tuples

    def getEventQ_size(self, lane_id):
        return self.lanes[lane_id].EvQ.getOccup()

    def get_lane_by_policy(self, curr_lane, policy):
        pol = int(policy)
        if pol == 0:
            return curr_lane
        policy_map = {
            0: [0, 0, 0],
            1: [0, 64, 0],
            2: [0, 32, 0],
            3: [32, 64, 0],
            4: [0, 32, 1],
            5: [32, 64, 1],
            6: [0, 64, 1],
            7: [0, 0, 2],  # this is UD choice not to be done here..
        }
        start_ln = policy_map[pol][0]
        end_ln = policy_map[pol][1]
        policy_ln = curr_lane
        check = policy_map[pol][2]
        q_val = 65536 if check == 0 else 0
        for xln in range(start_ln, end_ln):
            if (check == 0 and q_val > self.lanes[xln].EvQ.getOccup()) or (
                check != 0 and q_val < self.lanes[xln].EvQ.getOccup()
            ):
                q_val = self.lanes[xln].EvQ.getOccup
                policy_ln = xln
        return policy_ln

    def dumpEventQ(self, lane_id):
        for ev in self.lanes[lane_id].EvQ.events:
            ev.printOut(stage_trace)


# ======  UDP Lane Logical Architecture Class ======
class VirtualEngineLane:
    # def __init__(self, lane_id, numOfGpr, LM, perf_file, perf_log_enable, up):
    def __init__(
        self,
        nwid,
        ud_idx,
        lane_id,
        numOfGpr,
        LM,
        perf_file,
        perf_log_enable,
        mmu: AddrTranslationEngine,
        up,
    ):
        self.laneudprsize = numOfGpr
        self.curr_event = None
        self.curr_thread = None
        self.upproc = up
        self.curr_event_sins = None
        self.program = None
        self.SBPB_BEGIN = 0
        self.initID = [0]
        self.init_prop = None
        self.network_id = (nwid & 0xFFFFFFC0) | (lane_id & 0x3F)
        self.ud_idx = ud_idx
        self.lane_id = lane_id
        self.metric = Metric(self.lane_id)
        self.metric.perf_log_enable = perf_log_enable
        self.OpBuffer = OpBuffer(2048, self.metric)
        self.EvQ = EventQueue(256, self.metric)
        self.tstable = ThreadStateTable(self.lane_id)
        self.LM = LM
        self.mmu = mmu
        self.scratchpad_base = 0
        # self.ds_base = self.lane_id * 4096
        self.ds_base = 0
        self.all_lanes_done = 0
        self.lane_state = "lane_init"
        self.current_states = []
        self.perf_file = perf_file
        self.sim = 0
        self.mm_offset = 0
        self.send_mm = None
        self.num_sends = 0
        self.actcount = 0
        self.return_state = 0
        self.pname = None
        self.period = 500  # Needs to come from simulator
        # self.last_exec_cycle = 0
        self.sb_size = 64
        self.sb_stream = BitArray(self.sb_size * 8, endian="little")

    def getCycle(self):
        return self.metric.last_exec_cycle

    def setEFA(self, efa):
        self.program = efa

    def pushEvent(self, event):
        self.EvQ.pushEvent(event)
        printd(
            f"Push Event NetworkID:{self.network_id} event_word:{event.event_word} eventQ_size:{self.EvQ.getOccup()}",
            stage_trace,
        )

    def pushOp(self, op):
        self.OpBuffer.setOp(op)
        printd(
            f"Push data (val={op} hex:{hex(op)}) into operand buffer. NetworkID: {self.network_id} New OpBuffer Size {self.OpBuffer.getSize()}",
            stage_trace,
        )

    def test(self):
        print("Lane:%d" % self.lane_id)

    def address_generate_unit(self, base, index_val):  # , size):
        base_val = self.rd_ear(base)
        # self.metric.cycle += 1
        printd(
            "AddrGen: base:%s, base_val:%d , index_val:%d"
            % (base, base_val, index_val),
            stage_trace,
        )
        return int(base_val) + int(index_val)

    def bitsToInt(self, x):
        sum = 0
        i = 0
        for b in x[::-1]:
            sum += int(b) << i
            i += 1
        return sum

    def printstats(self):
        self.metric.printstats()

    def setup_sim(
        self,
        efa,
        simdir,
        lm_addr_mode,
        scratchpad_base,
        sendmap,
        SBPB_BEGIN=0,
        initID=[0],
    ):
        self.program = copy.deepcopy(efa)
        self.SBPB_BEGIN = SBPB_BEGIN
        self.initID = self.program.get_init_state()
        self.init_prop = [Property("event", None)]
        assert len(self.init_prop) == len(
            initID
        ), "# of property must equal # of init states"
        self.pc = 0
        self.sim = 1
        # self.pname = "./" + simdir + "/ud" + str(self.ud_idx) + "_lane" + str(self.lane_id) + "_send.txt"
        ##self.shm_name = "ud" + str(self.ud_idx) + "_lane" + str(self.lane_id) + "_send"
        # with open(self.pname, "w+b") as fd:
        #    for _ in range(262144*2+4):
        #        val = struct.pack("i", 0)
        #        fd.write(val)
        # fd.close()
        # with open(self.pname, "r+b") as fd:
        #    self.send_mm = mmap.mmap(fd.fileno(), 1048576*2, access=mmap.ACCESS_WRITE, offset=0)
        #    #self.send_mm = mmap.mmap(-1, 1048576*2, self.shm_name)
        #    #self.send_mm = mmap.mmap(fd.fileno(), 16384*2, access=mmap.ACCESS_WRITE, offset=0)
        #    self.send_mm.seek(0)
        self.send_mm = sendmap
        self.scratchpad_base = scratchpad_base
        if lm_addr_mode == 1:
            self.ds_base = self.scratchpad_base + (
                self.lane_id << 16
            )  # Ivy bank private addressing mode
        else:
            self.ds_base = self.scratchpad_base
        self.program.calcUdpSize()

    # This is the only execute now!
    def executeEFAlane_sim(self, start_timestamp):
        # ====== efa program loaded to UpDown
        self.metric.Setup(self.perf_file, self.lane_id, self.sim)
        self.metric.initMetrics()
        self.metric.start_ticks = start_timestamp
        printd(
            "  VirtualEngineLane::executeEFAlane_sim - Lane_Num:%d Lane State:%s, EvQ:%d"
            % (self.lane_id, self.lane_state, self.EvQ.getOccup()),
            stage_trace,
            self.metric.curTimeStamp(),
        )

        if self.upproc.perf_log_internal_enable:
            self.metric.write_perf_log(
                0,
                self.lane_id,
                0,
                # 0, self.lane_id, self.curr_thread.tid,
                0,
                0,
                # self.curr_event.event_base, self.curr_event.event_label,
                set([PerfLogPayload.UD_QUEUE_STATS.value]),
            )

        self.metric.curr_event_scyc = self.metric.cycle
        self.send_mm.seek(0)
        self.num_sends = 0
        val = struct.pack("I", self.num_sends)
        self.send_mm.write(val)
        self.mm_offset = 4
        self.actcount = self.metric.total_acts
        execute_one_event = 1
        if self.EvQ.getOccup() == 0:
            # Lane has nothing to do
            # highly unlikely!
            self.return_state = 0
            return (
                self.num_sends,
                self.return_state,
                self.metric.cycle - self.metric.curr_event_scyc,
                self.metric.total_acts,
                self.metric.idle_cycles,
                self.metric.up_lm_read_bytes,
                self.metric.up_lm_write_bytes,
                self.metric.msg_ins,
                self.metric.mov_ins,
                self.metric.branch_ins,
                self.metric.al_ins,
                self.metric.yld_ins,
                self.metric.comp_ins,
                self.metric.cmpswp_ins,
                self.metric.total_trans,
                self.metric.event_q_max,
                self.metric.event_q_mean,
                self.metric.operand_q_max,
                self.metric.operand_q_mean,
                self.metric.user_counters[0],
                self.metric.user_counters[1],
                self.metric.user_counters[2],
                self.metric.user_counters[3],
                self.metric.user_counters[4],
                self.metric.user_counters[5],
                self.metric.user_counters[6],
                self.metric.user_counters[7],
                self.metric.user_counters[8],
                self.metric.user_counters[9],
                self.metric.user_counters[10],
                self.metric.user_counters[11],
                self.metric.user_counters[12],
                self.metric.user_counters[13],
                self.metric.user_counters[14],
                self.metric.user_counters[15],
            )
        else:
            # Setup the execution state from the thread and start execution
            # Q: what is the init state when a thread is issued!?
            top_event = self.EvQ.events[0]
            top_event_tid = top_event.thread_id  # & 0x00ff0000 >> 16
            top_event.printOutStr("Event queue top", stage_trace)
            if top_event_tid == 0xFF or not self.tstable.threadexists(top_event_tid):
                # Create a new thread and set the states
                newtid = self.tstable.getTID()
                printd(
                    "Create new thread on lane %d: Thread:%d" % (self.lane_id, newtid),
                    stage_trace,
                    self.metric.curTimeStamp(),
                )
                # Update event thread ID
                # Create Thread
                currthread = Thread(
                    newtid, self.OpBuffer, self.network_id, self.ds_base, top_event.mode
                )
                self.metric.num_threads += 1
                # Insert Thread into table
                self.tstable.addThreadtoTST(currthread)
                self.curr_thread = currthread
                # self.curr_thread.set_state([], 0, 8, 8)  # Marzi: (set using instructions in the prog)
                init_state = []
                for ID in self.initID:
                    init_state.append(self.program.get_state(ID))
                self.curr_thread.current_states = []
                # Create first activation - Is this the best way for UpDown - Andronicus?
                for init_idx in range(len(self.initID)):
                    self.curr_thread.current_states.append(
                        Activation(init_state[init_idx], Property("event", None))
                    )
                self.lane_state = "lane_init"
                # not necessary since SBP should be initialized in the program
                if self.curr_thread.thread_mode == 1:
                    self.curr_thread.SBP = self.SBPB_BEGIN << 3
                    # init_sbp_val = self.curr_thread.CR_Advance
                yield_term = 0
                yield_exec = 0
            else:
                # Not a new thread
                self.lane_state = "lane_init"
                currthread = self.tstable.getThread(top_event.thread_id)
                self.curr_thread = currthread
        # print("Executing EFA: len(current_states):%d" % len(current_states))
        if (
            self.lane_state == "lane_term" or self.lane_state == "lane_yield"
        ) and self.EvQ.getOccup() > 0:
            # We execute till we empty out the event queue
            assert len(self.curr_thread.current_states) > 0
            yield_term = 0
            yield_exec = 0
        while (
            (
                (self.lane_state == "lane_init")
                and (
                    (self.curr_thread.SBP + self.curr_thread.CR_Issue)
                    <= self.curr_thread.MaxSBP
                )
            )
            or self.curr_thread.current_states[0].property.p_type == "flag"
            or (
                self.curr_thread.current_states[0].property.p_type == "event"
                and self.EvQ.getOccup() > 0
                and execute_one_event
            )
            or self.curr_thread.current_states[0].property.p_type == "flag_majority"
            or (self.lane_state == "lane_init" and self.curr_thread.thread_mode == 0)
        ):
            printd(
                "STAGE BEGIN at lanestate %s and thread_mode: %d\n"
                % (self.lane_state, self.curr_thread.thread_mode),
                stage_trace,
                self.metric.curTimeStamp(),
            )
            # check whether if it is a flag state.
            # If it is, do not advance SBP and input stream
            current_stage_property_type = self.curr_thread.current_states[
                0
            ].property.p_type
            if (
                self.curr_thread.current_states[0].property.p_type != "flag"
                and self.curr_thread.current_states[0].property.p_type
                != "flag_majority"
                and self.curr_thread.current_states[0].property.p_type != "event"
                and self.curr_thread.thread_mode != 0
            ):
                # ISSUE BASED ON ISSUE WIDTH
                if self.curr_thread.rdMode == 1:  # read from SB
                    issue_data = self.sb_stream[
                        self.curr_thread.SBP : self.curr_thread.SBP
                        + self.curr_thread.CR_Issue
                    ].bin
                    issue_data = self.bitsToInt(issue_data)
                    printd(
                        f"SB_issue_data:{issue_data} [SBP:{self.curr_thread.SBP}]\n",
                        stage_trace,
                    )
                elif self.curr_thread.rdMode == 0:  # read from LM
                    src_addr = (
                        self.curr_thread.SBP + self.curr_thread.ds_base
                    )  # In LM mode SBP shows the byte address
                    self.mmu.validate(src_addr, 1)
                    src_addr = src_addr - self.scratchpad_base
                    if (
                        self.curr_thread.CR_Issue == 1
                    ):  # 1: 1 byte 2: 2bytes 3:4bytes 4: 8bytes
                        issue_data = self.LM.read_byte(src_addr)
                    elif self.curr_thread.CR_Issue == 2:
                        issue_data = self.LM.read_2bytes(src_addr)
                    elif self.curr_thread.CR_Issue == 3:
                        issue_data = self.LM.read_4bytes(src_addr)
                    elif self.curr_thread.CR_Issue == 4:
                        issue_data = self.LM.read_word(src_addr)
                    printd(
                        f"LM_issue_data:{issue_data} [SBP:{self.curr_thread.SBP}]\n",
                        stage_trace,
                    )

            else:
                issue_data = 0

            # ====== major processing loop ======
            next_states = []
            for (
                activation
            ) in (
                self.curr_thread.current_states
            ):  # Marzi question: should we change this since we might have only one activation at a time?
                next_activations, yield_term, yield_exec = self.executeActivation(
                    activation, issue_data
                )
                next_states = concatSet(next_states, next_activations)
            printd(
                "Lane %d finish stage: yield_term:%d, yield_exec:%d\n"
                % (self.lane_id, yield_term, yield_exec),
                stage_trace,
                self.metric.curTimeStamp(),
            )
            self.curr_thread.current_states = next_states
            for idx in range(len(self.curr_thread.UDPR)):
                self.curr_thread.UDPR[idx] = int(
                    self.curr_thread.UDPR[idx]
                )  # & 0xFFFFFFFFFFFFFFFF
            # To incerement SBP at the end of this stage
            if (
                current_stage_property_type != "flag"
                and current_stage_property_type != "flag_majority"
                and current_stage_property_type != "event"
                and self.curr_thread.thread_mode != 0
            ):
                # AUTO ADVANCE OF SBP (therefor initial SBP is - self.curr_thread.CR_Advance)
                self.curr_thread.SBP += self.curr_thread.CR_Advance

            if yield_term == 1:
                self.lane_state = "lane_term"
                if self.EvQ.getOccup() == 0:
                    self.return_state = -1
                    return (
                        self.num_sends,
                        self.return_state,
                        self.metric.cycle - self.metric.curr_event_scyc,
                        self.metric.total_acts,
                        self.metric.idle_cycles,
                        self.metric.up_lm_read_bytes,
                        self.metric.up_lm_write_bytes,
                        self.metric.msg_ins,
                        self.metric.mov_ins,
                        self.metric.branch_ins,
                        self.metric.al_ins,
                        self.metric.yld_ins,
                        self.metric.comp_ins,
                        self.metric.cmpswp_ins,
                        self.metric.total_trans,
                        self.metric.event_q_max,
                        self.metric.event_q_mean,
                        self.metric.operand_q_max,
                        self.metric.operand_q_mean,
                        self.metric.user_counters[0],
                        self.metric.user_counters[1],
                        self.metric.user_counters[2],
                        self.metric.user_counters[3],
                        self.metric.user_counters[4],
                        self.metric.user_counters[5],
                        self.metric.user_counters[6],
                        self.metric.user_counters[7],
                        self.metric.user_counters[8],
                        self.metric.user_counters[9],
                        self.metric.user_counters[10],
                        self.metric.user_counters[11],
                        self.metric.user_counters[12],
                        self.metric.user_counters[13],
                        self.metric.user_counters[14],
                        self.metric.user_counters[15],
                    )
            if yield_exec == 1:
                self.lane_state = "lane_yield"
                if self.EvQ.getOccup() == 0:
                    self.return_state = 0 if self.num_sends == 0 else self.num_sends
                    return (
                        self.num_sends,
                        self.return_state,
                        self.metric.cycle - self.metric.curr_event_scyc,
                        self.metric.total_acts,
                        self.metric.idle_cycles,
                        self.metric.up_lm_read_bytes,
                        self.metric.up_lm_write_bytes,
                        self.metric.msg_ins,
                        self.metric.mov_ins,
                        self.metric.branch_ins,
                        self.metric.al_ins,
                        self.metric.yld_ins,
                        self.metric.comp_ins,
                        self.metric.cmpswp_ins,
                        self.metric.total_trans,
                        self.metric.event_q_max,
                        self.metric.event_q_mean,
                        self.metric.operand_q_max,
                        self.metric.operand_q_mean,
                        self.metric.user_counters[0],
                        self.metric.user_counters[1],
                        self.metric.user_counters[2],
                        self.metric.user_counters[3],
                        self.metric.user_counters[4],
                        self.metric.user_counters[5],
                        self.metric.user_counters[6],
                        self.metric.user_counters[7],
                        self.metric.user_counters[8],
                        self.metric.user_counters[9],
                        self.metric.user_counters[10],
                        self.metric.user_counters[11],
                        self.metric.user_counters[12],
                        self.metric.user_counters[13],
                        self.metric.user_counters[14],
                        self.metric.user_counters[15],
                    )
            else:
                self.lane_state = "lane_init"

            if (
                self.lane_state == "lane_term" or self.lane_state == "lane_yield"
            ) and self.EvQ.getOccup() > 0:
                top_event = self.EvQ.events[0]
                top_event_tid = top_event.thread_id  # & 0x00ff0000 >> 16
                top_event.printOutStr("Event queue top", stage_trace)
                if top_event_tid == 0xFF or not self.tstable.threadexists(
                    top_event_tid
                ):
                    # Create a new thread and set the states
                    newtid = self.tstable.getTID()
                    printd(
                        "  Create new thread on lane %d: tid=%d"
                        % (self.lane_id, newtid),
                        stage_trace,
                        self.metric.curTimeStamp(),
                    )
                    # Update event thread ID
                    # Create Thread
                    currthread = Thread(
                        newtid,
                        self.OpBuffer,
                        self.network_id,
                        self.ds_base,
                        top_event.mode,
                    )
                    self.metric.num_threads += 1
                    # Insert Thread into table
                    self.tstable.addThreadtoTST(currthread)
                    self.curr_thread = currthread
                    # self.curr_thread.set_state([], 0, 8, 8)  # Marzi
                    init_state = []
                    for ID in self.initID:
                        init_state.append(self.program.get_state(ID))
                    self.curr_thread.current_states = []
                    for init_idx in range(len(self.initID)):
                        self.curr_thread.current_states.append(
                            Activation(init_state[init_idx], Property("event", None))
                        )
                    # Update UDP base
                    self.lane_state = "lane_init"
                    next_states = []
                    # Not necessary since SBP should be initialized in program
                    if self.curr_thread.thread_mode == 1:
                        self.curr_thread.SBP = self.SBPB_BEGIN << 3
                        # init_sbp_val = self.curr_thread.CR_Advance
                    yield_term = 0
                    yield_exec = 0
                else:
                    self.lane_state = "lane_init"
                    next_states = []
                    currthread = self.tstable.getThread(top_event.thread_id)
                    self.curr_thread = currthread

            if self.sim:
                execute_one_event = 0

            # ====== detect non-active error, if find, abort
            if (not yield_term) and len(self.curr_thread.current_states) == 0:
                print(
                    "NWID: %d ERROR!, all no active states, not allowed for now"
                    % self.network_id
                )
                exit()

    def executeActivation(self, activation, input_label):
        property = activation.property
        state = activation.state
        state.exe_count += 1
        # ====== select the transitions ======
        if property.p_type == "common":
            trans = [state.trans[0]]
        elif property.p_type == "flag" or property.p_type == "flag_majority":
            translabel = self.curr_thread.rd_register("UDPR_0")
            trans = state.get_tran(translabel)
        elif property.p_type == "event":
            if self.EvQ.isEmpty():
                print("Lane:%d We should never get here!" % self.lane_id)

            event = self.EvQ.popEvent()
            continuation = self.curr_thread.rd_obbuffer("OB_0")
            # self.curr_thread.opaddr = continuation
            # if event.thread_id == 0xFF:
            if continuation != 0x7FFFFFFFFFFFFFFF:
                # Update event thread ID
                event.setthreadid(self.curr_thread.tid)
                printd(
                    f"Pop continuation from OpBuffer: {continuation}",
                    stage_trace,
                    self.metric.curTimeStamp(),
                )
                if (continuation & 0xFFFFFFFFFFFFFFFF) != 0xFFFFFFFFFFFFFFFF:
                    ret_cont = createEvent(continuation)
                    self.curr_thread.update(event, ret_cont, event.mode)
            else:
                # ret_cont = createEvent(continuation)
                self.curr_thread.curr_event = event
                self.curr_thread.thread_mode = event.mode
            self.OpBuffer.clearOp(1)
            # if (continuation & 0xFFFFFFFFFFFFFFFF) != 0xFFFFFFFFFFFFFFFF:
            #    ret_cont, thread_mode = createEvent(continuation)
            #    self.curr_thread.update(event, ret_cont, thread_mode)

            self.curr_event_sins = self.metric.total_acts
            self.metric.num_events += 1
            event.printOut(progress_trace, self.metric.curTimeStamp())
            trans = state.get_tran(event.event_label)
            self.curr_event = event
            # Andronicus : Check this later
            if event.cycle >= self.metric.last_exec_cycle:
                self.metric.idle_cycles += event.cycle - self.metric.last_exec_cycle
                self.metric.cycles_bins[
                    (event.cycle // self.metric.cycles_bin_step)
                ] += (event.cycle - self.metric.last_exec_cycle)
                self.metric.last_exec_cycle = event.cycle
        else:
            trans = state.get_tran(input_label)

        # ====== signature fail, look for majority transition
        # if not found, which means signature fail in machine level
        if len(trans) == 0:
            if property.p_type == "majority" or property.p_type == "flag_majority":
                trans = state.get_tran_byAnnotation("majority")
                # in machine code, majority_majirityCarry is implemented by majority transition of majority transition
                if len(trans) == 0:
                    trans = state.get_tran_byAnnotation("majority_majorityCarry")
                if len(trans) == 0:
                    trans = state.get_tran_byAnnotation("majority_defaultCarry")
            if property.p_type == "default" or property.p_type == "flag_default":
                # ====== in machine level , this default transition is implemented as basic
                # the destination state doesn't have default state
                trans = state.get_tran_byAnnotation("default")
                if len(trans) == 0:
                    # ====== in machine level, this default transition is implemented as defaultCarry, here is for emulator
                    trans = state.get_tran_byAnnotation("default_defaultCarry")
                if len(trans) == 0:
                    trans = state.get_tran_byAnnotation("default_majorityCarry")
                def_activation, forked_activations = self.executeTransition(trans[0])
                return self.executeActivation(def_activation, input_label)

            # ====== No transition, deactivate this state
            else:
                pass
        # ====== we execute the selected transition. May get several activations back
        yield_term = 0
        yield_exec = 0
        dst_activations = []
        for tr in trans:
            self.metric.TranSetBase()
            (
                next_activation,
                forked_activations,
                yield_term,
                yield_exec,
            ) = self.executeTransition(tr)
            self.metric.TranCycleDelta(tr)
            self.metric.TranCycleLabelDelta(tr)
            dst_activations.append(next_activation)
            if forked_activations is not None:
                dst_activations = concatSet(dst_activations, forked_activations)

        return dst_activations, yield_term, yield_exec

    def executeTransition(self, transition):
        dst_state = transition.dst
        forked_activations = None
        # ====== each transition executed in 1 cycle
        self.metric.cycle += 1
        self.metric.exec_cycles += 1
        self.metric.last_exec_cycle += 1
        self.metric.total_trans += 1
        self.metric.TranGroupBin(transition)
        transition.exe_count += 1
        transition.printOut(stage_trace, self.metric.curTimeStamp())
        # ====== transition carrying property ======
        if (
            transition.anno_type == "defaultCarry"
            or transition.anno_type == "default_defaultCarry"
        ):
            dst_property = Property("default", "DEF_tran_addr")
        elif transition.anno_type == "majorityCarry":
            dst_property = Property("majority", "MJ_tran_addr")
        elif (
            transition.anno_type == "majority_majorityCarry"
            or transition.anno_type == "default_majorityCarry"
        ):
            dst_property = Property("majority", "MJ_tran_addr")
        elif (
            transition.anno_type == "commonCarry"
            or transition.anno_type == "commonCarry_with_action"
        ):
            dst_property = Property("common", None)
        elif (
            transition.anno_type == "flagCarry"
            or transition.anno_type == "flagCarry_with_action"
        ):
            dst_property = Property("flag", None)
        elif transition.anno_type == "eventCarry":
            dst_property = Property("event", None)
        else:
            dst_property = Property("NULL", None)

        # ====== execute actions one by one ======
        yield_exec = 0
        seqnum = 0
        yield_term = 0
        if transition.hasActions():
            # for action in transition.actions:
            numActions = transition.getSize()
            while yield_exec == 0 and seqnum < numActions:
                # ====== action can modify the destination state's
                # property, and fork multiple activations ======
                action = transition.getAction(seqnum)
                # printd(
                #     "Lane: %d exec-Trans-action:%s, yield_exec:%d, seqnum:%d, numActions:%d"
                #     % (self.lane_id, action.opcode, yield_exec, seqnum, numActions),
                #     stage_trace,
                # )
                (
                    action_dst_property,
                    forked_activations,
                    yield_exec,
                    next_seqnum,
                    yield_term,
                ) = self.actionHandler(action, seqnum)

                # ====== if action changes the property, we need to
                # apply it to destination state ======
                seqnum = next_seqnum
                if action_dst_property is not None:
                    dst_property = action_dst_property

        # Automatic handling of SB refill
        if self.curr_thread.thread_mode == 1 and self.curr_thread.rdMode == 1:
            if (self.curr_thread.SBP + self.curr_thread.CR_Advance) >= (
                self.sb_size * 8
            ):
                # execute the sb_refill without changing the state of the past code
                block_id = "sb_refill"
                if block_id not in self.program.sharedBlock:
                    action.printOut(error)
                    exit()
                action_list = self.program.sharedBlock[block_id]
                forked_activations = None
                yield_exec = 0
                yield_term = 0
                seqnum = 0
                while yield_exec == 0 and seqnum < len(action_list):
                    shared_act = action_list[seqnum]
                    (
                        action_dst_property,
                        forked_activations,
                        yield_exec,
                        next_seqnum,
                        yield_term,
                    ) = self.actionHandler(shared_act, seqnum)
                    seqnum = next_seqnum
                    # ====== if action changes the property, we need to
                    # apply it to destination state ======
                    if action_dst_property is not None:
                        printd(
                            "ERROR: In this action block, there should not be any change to the destination state property!",
                            stage_trace,
                        )
                        action.printOut(error)
                        exit()

        # Automatic handling of termination based on MaxSBP
        elif self.curr_thread.thread_mode == 1 and self.curr_thread.rdMode == 0:
            printd(
                f"BEFORE INPUT TERMINATION: (SBP:{self.curr_thread.SBP} issue:{self.curr_thread.CR_Issue} max:{self.curr_thread.MaxSBP})",
                stage_trace,
            )
            if (
                self.curr_thread.SBP
                + self.curr_thread.CR_Advance
                + self.curr_thread.CR_Issue
            ) > self.curr_thread.MaxSBP:
                printd(f"INPUT TERMINATION: (SBP:{self.curr_thread.SBP})", stage_trace)
                # execute the end_of_input_terminate without changing the state of the past code
                block_id = "end_of_input_terminate"
                if block_id not in self.program.sharedBlock:
                    action.printOut(error)
                    exit()
                action_list = self.program.sharedBlock[block_id]
                forked_activations = None
                yield_exec = 0
                yield_term = 0
                seqnum = 0
                while yield_exec == 0 and seqnum < len(action_list):
                    shared_act = action_list[seqnum]
                    (
                        action_dst_property,
                        forked_activations,
                        yield_exec,
                        next_seqnum,
                        yield_term,
                    ) = self.actionHandler(shared_act, seqnum)
                    seqnum = next_seqnum
                    # ====== if action changes the property, we need to
                    # apply it to destination state ======
                    if action_dst_property is not None:
                        printd(
                            "ERROR: In this action block, there should not be any change to the destination state property!",
                            stage_trace,
                        )
                        action.printOut(error)
                        exit()

        # Andronicus : Check if these lane_states are still required?
        if yield_exec == 1:
            self.lane_state = "lane_yield"
        if yield_term == 1:
            self.lane_state = "lane_term"
        return (
            Activation(dst_state, dst_property),
            forked_activations,
            yield_term,
            yield_exec,
        )

    def actionHandler(self, action, seqnum):
        dst_property = None
        forked_activations = None
        yield_exec = 0
        yield_term = 0
        seqnum_set = 0
        next_seqnum = seqnum
        action.printOut(stage_trace, self.metric.curTimeStamp())
        self.metric.total_acts += 1
        # ====== action executed at least 1 cycle, more cycles in detail action
        self.metric.cycle += 1
        start_exec_cycles = self.metric.exec_cycles
        self.metric.exec_cycles += 1
        action.exe_count += 1
        # ======  Action Dispather ======
        if action.opcode == "set_state_property" or action.opcode == "ssprop":
            dst_property = self.do_set_state_property(action)
        elif (
            action.opcode == "hash_sb32" or action.opcode == "hashsb32"
        ):  # Come back later
            self.do_hash_sb32(action)
        elif action.opcode == "hash_sb64" or action.opcode == "hashsb64":
            self.do_hash_sb64(action)
        elif action.opcode == "hash_lm64" or action.opcode == "hashl64":
            self.do_hash_lm64(action)
        elif action.opcode == "hash":
            self.do_hash(action)
        elif action.opcode == "hash_lm" or action.opcode == "hashl":
            self.do_hash_lm(action)
        elif (
            action.opcode == "move"
            or action.opcode == "movrl"
            or action.opcode == "movlr"
        ):
            self.metric.mov_ins += 1
            self.do_move(action)
        elif action.opcode == "move_word":
            self.metric.mov_ins += 1
            self.do_move_word(action)
        elif action.opcode == "movwlr" or action.opcode == "movwrl":
            self.metric.mov_ins += 1
            self.do_movw(action)
        elif action.opcode == "mov_lm2sb" or action.opcode == "movlsb":
            self.metric.mov_ins += 1
            self.do_mov_lm2sb(action)
        elif action.opcode == "mov_lm2reg":  # For Ivy?
            self.metric.mov_ins += 1
            self.metric.probes += 1
            self.do_mov_lm2reg(action)
        elif action.opcode == "mov_reg2lm":
            self.metric.mov_ins += 1
            self.do_mov_reg2lm(action)
        elif action.opcode == "mov_ear2lm":
            self.metric.mov_ins += 1
            self.do_mov_ear2lm(action)
        elif action.opcode == "mov_lm2ear":
            self.metric.mov_ins += 1
            self.do_mov_lm2ear(action)
        elif action.opcode == "mov_reg2reg":
            self.metric.mov_ins += 1
            self.do_mov_reg2reg(action)
        elif action.opcode == "mov_eqt2reg":
            # self.metric.op_ins += 1
            self.metric.mov_ins += 1
            self.metric.event_ins += 1
            self.do_mov_eqt2reg(action)
        elif action.opcode == "mov_ob2reg":
            self.metric.op_ins += 1
            self.metric.mov_ins += 1
            self.do_mov_ob2reg(action)
        elif action.opcode == "mov_ob2ear":
            self.metric.op_ins += 1
            self.metric.mov_ins += 1
            self.do_mov_ob2ear(action)
        elif action.opcode == "swizzle" or action.opcode == "swiz":
            self.do_swizzle(action)
        elif action.opcode == "ev_update_1" or action.opcode == "evi":
            self.do_ev_update_1(action)
        elif action.opcode == "ev_update_2" or action.opcode == "evii":
            self.do_ev_update_2(action)
        elif action.opcode == "ev_update_reg_imm":
            self.do_ev_update_reg_imm(action)
        elif action.opcode == "ev_update_reg_2" or action.opcode == "ev":
            self.do_ev_update_reg_2(action)
        elif action.opcode == "evlb":
            self.do_evlb(action)
        elif action.opcode == "compare_string":
            self.do_compare_string(action)
        elif action.opcode == "compare_string_from_out":
            self.do_compare_string_from_out(action)
        elif action.opcode == "subi":
            self.metric.al_ins += 1
            self.do_sub_immediate(action)
        elif action.opcode == "addi":
            self.metric.al_ins += 1
            self.do_add_immediate(action)
        elif action.opcode == "muli":
            self.metric.al_ins += 1
            self.do_mul_immediate(action)
        elif action.opcode == "divi":
            self.metric.al_ins += 1
            self.do_div_immediate(action)
        elif action.opcode == "modi":
            self.metric.al_ins += 1
            self.do_mod_immediate(action)
        elif action.opcode == "copy" or action.opcode == "bcpyll":
            self.do_copy(action)
        elif action.opcode == "copy_ob_lm":
            self.do_copy_ob_lm(action)
        elif action.opcode == "bcopy_ops" or action.opcode == "bcpyol":
            self.do_bcopy_ops(action)
        elif action.opcode == "bcpyoli":
            self.do_bcpyoli(action)
        elif action.opcode == "copy_imm" or action.opcode == "bcpylli":
            self.do_copy_imm(action)
        elif action.opcode == "copy_from_out":
            self.do_copy_from_out(action)
        elif action.opcode == "copy_from_out_imm":
            self.do_copy_from_out_imm(action)
        elif action.opcode == "sub":
            self.metric.al_ins += 1
            self.do_sub_reg(action)
        elif action.opcode == "add":
            self.metric.al_ins += 1
            self.do_add_reg(action)
        elif action.opcode == "mul":
            self.metric.al_ins += 1
            self.do_mul_reg(action)
        elif action.opcode == "div":
            self.metric.al_ins += 1
            self.do_div_reg(action)
        elif action.opcode == "mod":
            self.metric.al_ins += 1
            self.do_mod_reg(action)
        elif action.opcode == "bitclr":
            self.metric.al_ins += 1
            self.do_bitclr_reg(action)
        elif action.opcode == "bitset":
            self.metric.al_ins += 1
            self.do_bitset_reg(action)
        elif action.opcode == "put_1byte_imm" or action.opcode == "movil1":
            self.do_put1byte_imm(action)
        elif action.opcode == "put_2byte_imm" or action.opcode == "movil2":
            self.do_put2byte_imm(action)
        elif action.opcode == "lshift_add_imm" or action.opcode == "sladdii":
            self.metric.al_ins += 1
            self.do_lshift_add_imm(action)
        elif action.opcode == "rshift_add_imm" or action.opcode == "sraddii":
            self.metric.al_ins += 1
            self.do_rshift_add_imm(action)
        elif action.opcode == "lshift_and_imm" or action.opcode == "slandii":
            self.metric.al_ins += 1
            self.do_lshift_and_imm(action)
        elif action.opcode == "rshift_and_imm" or action.opcode == "srandii":
            self.metric.al_ins += 1
            self.do_rshift_and_imm(action)
        elif action.opcode == "lshift_or_imm" or action.opcode == "slorii":
            self.metric.al_ins += 1
            self.do_lshift_or_imm(action)
        elif action.opcode == "rshift_or_imm" or action.opcode == "srorii":
            self.metric.al_ins += 1
            self.do_rshift_or_imm(action)
        elif action.opcode == "lshift_sub_imm" or action.opcode == "slsubii":
            self.metric.al_ins += 1
            self.do_lshift_sub_imm(action)
        elif action.opcode == "rshift_sub_imm" or action.opcode == "srsubii":
            self.metric.al_ins += 1
            self.do_rshift_sub_imm(action)
        elif action.opcode == "cmpswp_i" or action.opcode == "cswpi":
            self.metric.cmpswp_ins += 1
            self.do_cmpswp_i(action)
        elif action.opcode == "cmpswp" or action.opcode == "cswp":
            self.metric.cmpswp_ins += 1
            self.do_cmpswp(action)
        elif action.opcode == "cmpswp_ri":
            self.metric.cmpswp_ins += 1
            self.do_cmpswp_ri(action)
        elif action.opcode == "put_bytes":
            self.do_putbytes(action)
        elif action.opcode == "comp_lt" or action.opcode == "clti":
            self.metric.comp_ins += 1
            self.do_compare_less_than(action)
        elif action.opcode == "comp_gt" or action.opcode == "cgti":
            self.metric.comp_ins += 1
            self.do_compare_great_than(action)
        elif action.opcode == "comp_eq" or action.opcode == "ceqi":
            self.metric.comp_ins += 1
            self.do_compare_equal(action)
        elif action.opcode == "compreg_eq" or action.opcode == "ceq":
            self.metric.comp_ins += 1
            self.do_compare_reg_equal(action)
        elif action.opcode == "compreg_lt" or action.opcode == "clt":
            self.metric.comp_ins += 1
            self.do_compare_reg_less_than(action)
        elif action.opcode == "compreg_gt" or action.opcode == "cgt":
            self.metric.comp_ins += 1
            self.do_compare_reg_great_than(action)
        elif action.opcode == "compreg":
            self.metric.probes += 1
            self.metric.comp_ins += 1
            self.do_compare_reg(action)
        elif (
            action.opcode == "bitwise_or"
            or action.opcode == "orr"
            or action.opcode == "or"
        ):
            self.metric.al_ins += 1
            self.do_bitwise_or(action)
        elif (
            action.opcode == "bitwise_and"
            or action.opcode == "andr"
            or action.opcode == "and"
        ):
            self.metric.al_ins += 1
            self.do_bitwise_and(action)
        elif (
            action.opcode == "bitwise_xor"
            or action.opcode == "xorr"
            or action.opcode == "xor"
        ):
            self.metric.al_ins += 1
            self.do_bitwise_xor(action)
        elif action.opcode == "lshift_or" or action.opcode == "slori":
            self.metric.al_ins += 1
            self.do_lshift_or(action)
        elif action.opcode == "rshift_or" or action.opcode == "srori":
            self.metric.al_ins += 1
            self.do_rshift_or(action)
        elif action.opcode == "lshift_and" or action.opcode == "slandi":
            self.metric.al_ins += 1
            self.do_lshift_and(action)
        elif action.opcode == "rshift_and" or action.opcode == "srandi":
            self.metric.al_ins += 1
            self.do_rshift_and(action)
        elif action.opcode == "lshift" or action.opcode == "sli":
            self.metric.al_ins += 1
            self.do_lshift(action)
        elif action.opcode == "rshift" or action.opcode == "sri":
            self.metric.al_ins += 1
            self.do_rshift(action)
        elif (
            action.opcode == "arithrshift" or action.opcode == "sari"
        ):  # added by Marziyeh (arithrshifts)
            self.metric.al_ins += 1
            self.do_arithrshift(action)
        elif action.opcode == "lshift_t" or action.opcode == "sl":
            self.metric.al_ins += 1
            self.do_lshift_t(action)
        elif action.opcode == "rshift_t" or action.opcode == "sr":
            self.metric.al_ins += 1
            self.do_rshift_t(action)
        elif (
            action.opcode == "arithrshift_t" or action.opcode == "sar"
        ):  # added by Marziyeh (arithrshifts)
            self.metric.al_ins += 1
            self.do_arithrshift_t(action)
        elif action.opcode == "get_bytes":
            self.do_getbytes(action)
        elif action.opcode == "get_bytes_from_out":
            self.do_getbytes_from_out(action)
        elif action.opcode == "bitwise_and_imm" or action.opcode == "andi":
            self.metric.al_ins += 1
            self.do_bitwise_and_imm(action)
        elif action.opcode == "bitwise_or_imm" or action.opcode == "ori":
            self.metric.al_ins += 1
            self.do_bitwise_or_imm(action)
        elif action.opcode == "bitwise_xor_imm" or action.opcode == "xori":
            self.metric.al_ins += 1
            self.do_bitwise_xor_imm(action)
        elif action.opcode == "swap_bytes":
            self.do_swap_bytes(action)
        elif action.opcode == "mask_or":
            self.metric.al_ins += 1
            self.do_mask_or(action)
        elif action.opcode == "goto" or action.opcode == "tranCarry_goto":
            self.metric.goto_ins += 1
            dst_property, forked_activations, yield_exec, yield_term = self.do_goto(
                action
            )
        elif action.opcode == "set_issue_width" or action.opcode == "siw":
            self.do_set_issue_width(action)
        elif action.opcode == "set_complete":
            self.do_set_complete(action)
        elif action.opcode == "refill":
            self.do_refill(action)
        elif action.opcode == "mov_imm2reg" or action.opcode == "movir":
            self.metric.mov_ins += 1
            self.do_mov_imm2reg(action)
        elif (
            action.opcode == "mov_sb2reg" or action.opcode == "movsbr"
        ):  # added by Marzi
            self.metric.mov_ins += 1
            self.do_mov_sb2reg(action)
        elif action.opcode == "branch":
            self.metric.branch_ins += 1
            (
                next_seqnum,
                seqnum_set,
                dst_property,
                forked_activations,
                yield_exec,
                yield_term,
            ) = self.do_branch(action)
        elif action.opcode == "jmp":
            self.metric.branch_ins += 1
            (
                next_seqnum,
                seqnum_set,
                dst_property,
                forked_activations,
                yield_exec,
                yield_term,
            ) = self.do_jmp(action)
        # New Send instruction interface
        elif action.opcode == "sendr":
            self.metric.msg_ins += 1
            self.do_sendr(action)
        elif action.opcode == "sendr3":
            self.metric.msg_ins += 1
            self.do_sendr3(action)
        elif action.opcode == "sendmr":
            self.metric.msg_ins += 1
            self.do_sendmr(action)
        elif action.opcode == "sendmr2":
            self.metric.msg_ins += 1
            self.do_sendmr2(action)
        elif action.opcode == "sendm":
            self.metric.msg_ins += 1
            self.do_sendm(action)
        elif action.opcode == "send4":  # Legacy Send4 instruction interface
            self.metric.msg_ins += 1
            self.do_send4(action)
        elif action.opcode == "send":
            self.metric.msg_ins += 1
            self.do_send(action)
        elif action.opcode == "sendops" or action.opcode == "sendmops":
            self.metric.msg_ins += 1
            self.do_sendops(action)
        elif action.opcode == "send_wcont":
            # PSEUDO:   send_wcont    Xe      Xc      Xptr    $len
            # HERE:     send_wcont    event   cont    op1     op2
            self.metric.msg_ins += 1
            self.do_send_wcont(action)
        elif action.opcode == "sendr_wcont":
            # PSEUDO:   sendr_wcont   Xe      Xc      X1      X2
            # HERE:     sendr_wcont   event   cont    op1     op2
            self.metric.msg_ins += 1
            self.do_sendr_wcont(action)
        elif action.opcode == "sendr3_wcont":
            # PSEUDO:   sendr3_wcont  Xe      Xc      X1      X2      X3
            # HERE:     sendr3_wcont  event   cont    op1     op2     op3
            self.metric.msg_ins += 1
            self.do_sendr3_wcont(action)
        elif action.opcode == "sendops_wcont":
            # PSEUDO:   sendops_wcont     Xe      Xc      Xop     $numops
            # HERE:     sendops_wcont     event   cont    op1     op2
            self.metric.msg_ins += 1
            self.do_sendops_wcont(action)
        elif action.opcode == "send_wret":
            # PSEUDO:   send_wret     Xe        $cont_label     Xptr    $len    Xtmp1
            # HERE:     send_wret     event     cont            op1     op2     tmp_reg1
            self.metric.msg_ins += 1
            self.do_send_wret(action)
        elif action.opcode == "sendr_wret":
            # PSEUDO:   sendr_wret    Xe      $cont_label     X1      X2      Xtmp1
            # HERE:     sendr_wret    event   cont            op1     op2     tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendr_wret(action)
        elif action.opcode == "sendr3_wret":
            # PSEUDO:   sendr3_wret   Xe      $cont_label     X1      X2      X3      Xtmp1
            # HERE:     sendr3_wret   event   cont            op1     op2     op3     tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendr3_wret(action)
        elif action.opcode == "sendops_wret":
            # PSEUDO:   sendops_wret  Xe      $cont_label     Xop     $numops     Xtmp1
            # HERE:     sendops_wret  event   cont            op1     op2         tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendops_wret(action)
        elif action.opcode == "send_dmlm_ld":
            # PSEUDO:   send_dmlm_ld  Xd      Xc      $len
            # HERE:     send_dmlm_ld  dst     cont    op1
            self.metric.msg_ins += 1
            self.do_send_dmlm_ld(action)
        elif action.opcode == "send_dmlm_ld_wret":
            # PSEUDO:   send_dmlm_ld_wret     Xd      $cont_label     $len    Xtmp1
            # HERE:     send_dmlm_ld_wret     dst     cont            op1     tmp_reg1
            self.metric.msg_ins += 1
            self.do_send_dmlm_ld_wret(action)
        elif action.opcode == "send_dmlm":
            # PSEUDO:   send_dmlm     Xd      Xc      Xptr        $len
            # HERE:     send_dmlm     dst     cont    op1         op2
            self.metric.msg_ins += 1
            self.do_send_dmlm(action)
        elif action.opcode == "sendr_dmlm":
            # PSEUDO:   sendr_dmlm    Xd      Xc      Xop1
            # HERE:     sendr_dmlm    dst     cont    op1
            self.metric.msg_ins += 1
            self.do_sendr_dmlm(action)
        elif action.opcode == "sendr2_dmlm":
            # PSEUDO:   sendr2_dmlm   Xd      Xc      Xop1    Xop2
            # HERE:     sendr2_dmlm   dst     cont    op1     op2
            self.metric.msg_ins += 1
            self.do_sendr2_dmlm(action)
        elif action.opcode == "send_dmlm_wret":
            # PSEUDO:   send_dmlm_wret    Xd      $cont_label     Xptr    $len    Xtmp1
            # HERE:     send_dmlm_wret    dst     cont            op1     op2     tmp_reg1
            self.metric.msg_ins += 1
            self.do_send_dmlm_wret(action)
        elif action.opcode == "sendr_dmlm_wret":
            # PSEUDO:   sendr_dmlm_wret   Xd      $cont_label     Xop1    Xtmp1
            # HERE:     sendr_dmlm_wret   dst     cont            op1     tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendr_dmlm_wret(action)
        elif action.opcode == "sendr2_dmlm_wret":
            # PSEUDO:   sendr2_dmlm_wret  Xd      $cont_label     Xop1    Xop2    Xtmp1
            # HERE:     sendr2_dmlm_wret  dst     cont            op1     op2     tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendr2_dmlm_wret(action)
        elif action.opcode == "sendops_dmlm_wret":
            # PSEUDO:   sendops_dmlm_wret     Xd      $cont_label     Xop     $numops     Xtmp1
            # HERE:     sendops_dmlm_wret     dst     cont            op1     op2         tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendops_dmlm_wret(action)
        elif action.opcode == "send_reply":
            # PSEUDO:   send_reply    Xptr    $len    Xtmp1
            # HERE:     send_reply    op1     op2     tmp_reg1
            self.metric.msg_ins += 1
            self.do_send_reply(action)
        elif action.opcode == "sendr_reply":
            # PSEUDO:   sendr_reply   Xop1    Xop2    Xtmp1
            # HERE:     sendr_reply   op1     op2     tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendr_reply(action)
        elif action.opcode == "sendr3_reply":
            # PSEUDO:   sendr3_reply  Xop1    Xop2    Xop3    Xtmp1
            # HERE:     sendr3_reply  op1     op2     op3     tmp_reg1
            self.metric.msg_ins += 1
            self.do_sendr3_reply(action)
        elif action.opcode == "send_any_wcont":
            # PSEUDO:   send_any_wcont    Xe      Xc      Xptr    <X1, X2 Xn>    Xtmp1
            # HERE:     send_any_wcont    event   cont    op1     reglist         tmp_reg1
            self.metric.msg_ins += 1
            self.do_send_any_wcont(action)
        elif action.opcode == "send_any_wret":
            # PSEUDO:   send_any_wret     Xe      $cont       Xptr    <X1, X2 Xn>    Xtmp1
            # HERE:     send_any_wret     event   cont        op1     reglist         tmp_reg1
            self.metric.msg_ins += 1
            self.do_send_any_wret(action)
        elif action.opcode == "yield":
            self.metric.yld_ins += 1
            yield_exec = self.do_yield(action)
        elif action.opcode == "yield_terminate" or action.opcode == "yieldt":
            self.metric.yld_ins += 1
            yield_exec, yield_term = self.do_yield_terminate(action)
        elif action.opcode == "print":
            self.metric.total_acts -= 1
            self.metric.cycle -= 1
            self.metric.exec_cycles -= 1
            self.do_print(action)
        elif action.opcode == "perflog":
            self.metric.total_acts -= 1
            self.metric.cycle -= 1
            self.metric.exec_cycles -= 1
            self.do_perflog(action)
        elif action.opcode == "userctr":
            self.metric.total_acts -= 1
            self.metric.cycle -= 1
            self.metric.exec_cycles -= 1
            self.do_user_ctr(action)
        elif action.opcode == "lmmemcheck":
            self.metric.total_acts -= 1
            self.metric.cycle -= 1
            self.metric.exec_cycles -= 1
            self.do_lmmemcheck(action)
        elif action.opcode == "instrans":
            self.metric.total_acts -= 1
            self.metric.cycle -= 1
            self.metric.exec_cycles -= 1
            self.do_insert_translation(action)
        elif action.opcode == "fp_div":
            self.metric.yld_ins += 1
            self.do_fp_div(action)
        elif action.opcode == "fp_add":
            self.metric.yld_ins += 1
            self.do_fp_add(action)
        # Added by Marzi
        elif (
            action.opcode == "fmadd"
            or action.opcode == "fmadd.64"
            or action.opcode == "fmadd.32"
            or action.opcode == "fmadd.b16"
            or action.opcode == "vmadd.32"
            or action.opcode == "fmadd.b16"
            or action.opcode == "fmadd.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fmadd(action)
        elif (
            action.opcode == "fadd"
            or action.opcode == "fadd.64"
            or action.opcode == "fadd.32"
            or action.opcode == "fadd.b16"
            or action.opcode == "vadd.32"
            or action.opcode == "fadd.b16"
            or action.opcode == "fadd.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fadd(action)
        elif (
            action.opcode == "fsub"
            or action.opcode == "fsub.64"
            or action.opcode == "fsub.32"
            or action.opcode == "fsub.b16"
            or action.opcode == "vsub.32"
            or action.opcode == "fsub.b16"
            or action.opcode == "fsub.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fsub(action)
        elif (
            action.opcode == "fmul"
            or action.opcode == "fmul.64"
            or action.opcode == "fmul.32"
            or action.opcode == "fmul.b16"
            or action.opcode == "vmul.32"
            or action.opcode == "fmul.b16"
            or action.opcode == "fmul.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fmul(action)
        elif (
            action.opcode == "fdiv"
            or action.opcode == "fdiv.64"
            or action.opcode == "fdiv.32"
            or action.opcode == "fdiv.b16"
            or action.opcode == "vdiv.32"
            or action.opcode == "fdiv.b16"
            or action.opcode == "fdiv.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fdiv(action)
        elif (
            action.opcode == "fsqrt"
            or action.opcode == "fsqrt.64"
            or action.opcode == "fsqrt.32"
            or action.opcode == "fsqrt.b16"
            or action.opcode == "vsqrt.32"
            or action.opcode == "fsqrt.b16"
            or action.opcode == "fsqrt.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fsqrt(action)
        elif (
            action.opcode == "fexp"
            or action.opcode == "fexp.64"
            or action.opcode == "fexp.32"
            or action.opcode == "fexp.b16"
            or action.opcode == "vexp.32"
            or action.opcode == "fexp.b16"
            or action.opcode == "fexp.i32"
        ):
            self.metric.fp_ins += 1
            self.do_fexp(action)
        elif action.opcode == "fcnvt_i2f":
            self.metric.fp_ins += 1
            self.do_fcnvt_i2f(action)
        elif action.opcode == "fcnvt_f2i":
            self.metric.fp_ins += 1
            self.do_fcnvt_f2i(action)
        elif action.opcode == "vgt":
            self.do_vgt(action)
        elif action.opcode == "vfill":
            self.do_vfill(action)
        elif action.opcode == "put_bits" or action.opcode == "movbil":
            self.do_putbits(action)
        elif action.opcode == "get_bits" or action.opcode == "movblr":
            self.do_getbits(action)
        # ==============================
        if seqnum_set == 0:
            next_seqnum = int(seqnum) + 1
        self.metric.last_exec_cycle += self.metric.exec_cycles - start_exec_cycles

        return dst_property, forked_activations, yield_exec, next_seqnum, yield_term

    def rd_imm(self, imm, bits=32):
        #####PATCH FIX TODO bits is optional to support other calls. should be made required
        return sign(imm, bits)
    
    def rd_imm_u(self, imm, bits=16):
        return unsign(imm, bits)

    # ============ Detail Action Handler ===============
    def do_set_state_property(self, action):
        line = action.imm.split("::")
        p_type = line[0]

        if p_type == "flag":
            property = Property("flag", None)
        elif p_type == "common":
            property = Property("common", None)
        elif p_type == "majority":
            p_val = line[1]
            property = Property("majority", p_val)
        elif p_type == "flag_majority":
            p_val = line[1]
            property = Property("flag_majority", p_val)
        elif p_type == "default":
            p_val = line[1]
            property = Property("default", p_val)
        elif p_type == "flag_default":
            p_val = line[1]
            property = Property("flag_default", p_val)
        else:
            print("unrecognized property")
            exit()
        return property

    def do_hash_sb64(self, action):
        start = self.curr_thread.SBP  # Marzi
        # ====== align read 1 extra cycle
        # unaligned read 2 extra cycles
        if start % 8 == 0:
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

        else:
            self.metric.cycle += 2
            self.metric.exec_cycles += 2

        value = self.in_stream[start : start + 64].bin
        value = self.bitsToInt(value)
        entry_addr = CRC64.compute(value) + self.curr_thread.rd_register(
            action.src
        )  # using crc hash
        self.curr_thread.wr_register(action.dst, entry_addr)

    def do_hash_lm64(self, action):
        start = self.curr_thread.SBP
        value = LM_scratchpad.read_word(start << 4)
        entry_addr = CRC64.compute(value) + self.curr_thread.rd_register(
            action.src
        )  # using crc hash
        self.curr_thread.wr_register(action.dst, entry_addr)

    def do_hash(self, action):
        first_val = self.curr_thread.rd_register(action.src)
        second_val = self.curr_thread.rd_register(action.dst)
        entry_addr = CRC64.compute(first_val + second_val)
        self.curr_thread.wr_register(action.dst, entry_addr)

    def do_hash_lm(self, action):
        num_words = self.curr_thread.rd_imm(action.imm)
        src_addr = self.curr_thread.rd_register(action.src)
        hash_val = self.curr_thread.rd_register(action.dst)
        for i in range(num_words):
            hash_val = CRC64.compute(
                hash_val
                + LM_scratchpad.read_word(src_addr + 8 * i - self.scratchpad_base)
            )
        self.curr_thread.wr_register(action.dst, hash_val)

    def do_hash_sb32(self, action):
        hashTableBaseAddr = int(action.imm)
        # start = self.SBP
        start = self.curr_thread.SBP  # Marzi
        # ====== align read 1 extra cycle
        # unaligned read 2 extra cycles
        if start % 4 == 0:
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

        else:
            self.metric.cycle += 2
            self.metric.exec_cycles += 2

        value = self.in_stream[start : start + 32].bin
        value = self.bitsToInt(value)
        # ====== hash generates the entry index, each entry is 2 bytes
        entry_addr = hash_crc(value) * 2 + hashTableBaseAddr  # using crc hash
        self.curr_thread.wr_register(action.dst, entry_addr)

    def do_swizzle(self, action):
        swizzle_word = self.curr_thread.rd_register(action.dst)
        mask = self.curr_thread.rd_register(action.src)
        first_bit, flips = bitflips(mask)
        bswiz = swizzle(swizzle_word, first_bit, flips)
        printd(
            "swizzle_in %s:%lu, mask:%lu, swizzle_out:%lu" % (swizzle_word, mask, bswiz)
        )
        # Swizzle based mask
        self.curr_thread.wr_register(action.dst, bswiz)

    def do_move(self, action):
        if "ld" in action.lm_mode and (
            action.opcode == "movlr" or action.opcode == "move"
        ):
            base_addr = self.curr_thread.rd_register(action.src)
            data_addr = base_addr + self.rd_imm(action.imm2)
            num_bytes = self.rd_imm(action.imm)
            self.mmu.validate(data_addr, num_bytes)
            lm_addr = data_addr - self.scratchpad_base
            if num_bytes == 8:
                lm_data = self.LM.read_word(lm_addr)
            elif num_bytes == 4:
                lm_data = self.LM.read_4bytes(lm_addr)
            elif num_bytes == 2:
                lm_data = self.LM.read_2bytes(lm_addr)
            elif num_bytes == 1:
                lm_data = self.LM.read_byte(lm_addr)
            else:
                # print("not yet support "),
                action.printOut(error)
                exit()
            self.metric.up_lm_read_bytes += num_bytes
            self.curr_thread.wr_register(action.dst, lm_data)
            printd(
                f"  move ld - base {action.dst} {base_addr} data_addr {hex(data_addr)} num_bytes {num_bytes} "
                + f"offset {self.rd_imm(action.imm2)} data {lm_data}",
                stage_trace,
                self.metric.curTimeStamp(),
            )
            if "inc" in action.lm_mode:
                self.curr_thread.wr_register(action.src, base_addr + num_bytes)
        elif "st" in action.lm_mode and (
            action.opcode == "movrl" or action.opcode == "move"
        ):
            base_addr = self.curr_thread.rd_register(action.dst)
            data_addr = base_addr + self.rd_imm(action.imm2)
            if action.src == "X3":
                src_data = []
                for i in range(len(self.curr_thread.ops.operands)):
                    src_data.append(self.curr_thread.ops.getOp(i))
                num_bytes = len(src_data) * 8
                for obdata in src_data:
                    obdata = obdata & 0xFFFFFFFFFFFFFFFF
                    self.LM.write_word(data_addr, obdata)
                    data_addr += 8
            else:
                src_data = int(self.curr_thread.rd_register(action.src))
                num_bytes = self.rd_imm(action.imm)
                self.mmu.validate(data_addr, num_bytes)
                lm_addr = data_addr - self.scratchpad_base
                if num_bytes == 8:
                    self.LM.write_word(lm_addr, src_data)
                elif num_bytes == 4:
                    self.LM.write_4bytes(lm_addr, src_data)
                elif num_bytes == 2:
                    self.LM.write_2bytes(lm_addr, src_data)
                elif num_bytes == 1:
                    self.LM.write_byte(lm_addr, src_data)
                else:
                    # print("not yet support "),
                    action.printOut(error)
                    exit()
                printd(
                    f"  move st - base {action.dst} {base_addr} data_addr {hex(data_addr)} num_bytes {num_bytes} "
                    + f"offset {self.rd_imm(action.imm2)} data {src_data}",
                    stage_trace,
                    self.metric.curTimeStamp(),
                )
            self.metric.up_lm_write_bytes += num_bytes
            if "inc" in action.lm_mode:
                self.curr_thread.wr_register(action.dst, base_addr + num_bytes)

    def do_movw(self, action):
        if "ld" in action.lm_mode and action.opcode == "movwlr":
            src_offset = self.curr_thread.rd_register(action.src)
            # scaled_addr = src_offset << self.rd_imm(action.imm)
            base_addr = self.curr_thread.rd_register(action.rt)
            data_addr = base_addr + (src_offset << (self.rd_imm(action.imm) + 3))
            self.mmu.validate(data_addr, 8)
            lm_data = self.LM.read_word(data_addr - self.scratchpad_base)
            self.metric.up_lm_read_bytes += 8
            self.curr_thread.wr_register(action.dst, lm_data)
            printd(
                f"  move_word ld - src: {action.src} {src_offset} data_addr: {hex(data_addr)} "
                + f"scale: {(self.rd_imm(action.imm) + 3)} base: {base_addr} data: {lm_data}",
                stage_trace,
                self.metric.curTimeStamp(),
            )
            if "inc" in action.lm_mode:
                self.curr_thread.wr_register(action.src, src_offset + 1)
                printd(
                    f"inc - {action.src} new value {self.curr_thread.rd_register(action.src) }",
                    stage_trace,
                )
        elif "st" in action.lm_mode and action.opcode == "movwrl":
            dst_offset = self.curr_thread.rd_register(action.dst)
            # scaled_addr = dst_offset << self.rd_imm(action.imm)
            base_addr = self.curr_thread.rd_register(action.rt)
            data_addr = base_addr + (dst_offset << (self.rd_imm(action.imm) + 3))
            src_data = int(self.curr_thread.rd_register(action.src))
            self.mmu.validate(data_addr, 8)
            self.LM.write_word(data_addr - self.scratchpad_base, src_data)
            self.metric.up_lm_write_bytes += 8
            printd(
                f"  move_word st - dst: {action.dst} {dst_offset} data_addr: {hex(data_addr)} "
                + f"scale: {(self.rd_imm(action.imm) + 3)} offset: {base_addr} data: {src_data}",
                stage_trace,
                self.metric.curTimeStamp(),
            )
            if "inc" in action.lm_mode:
                self.curr_thread.wr_register(action.dst, dst_offset + 1)
                printd(
                    f"inc - {action.dst} new value {self.curr_thread.rd_register(action.dst) }",
                    stage_trace,
                )
        else:
            print(f"Wrong opcode and operands combination for {action.opcode}!")
            exit()

    def do_move_word(self, action):
        if "ld" in action.lm_mode:
            src_offset = self.curr_thread.rd_register(action.src)
            # scaled_addr = src_offset << self.rd_imm(action.imm)
            data_addr = self.curr_thread.rd_register(action.rt) + (
                src_offset << self.rd_imm(action.imm)
            )
            self.mmu.validate(data_addr, 8)
            lm_data = self.LM.read_word(data_addr - self.scratchpad_base)
            self.metric.up_lm_read_bytes += 8
            self.curr_thread.wr_register(action.dst, lm_data)
            printd(
                f"    move_word ld - src {action.src} {src_offset} data_addr {hex(data_addr)} "
                + f"offset {self.curr_thread.rd_register(action.rt)} data {lm_data}",
                stage_trace,
                self.metric.curTimeStamp(),
            )
            if "inc" in action.lm_mode:
                self.curr_thread.wr_register(action.src, src_offset + 1)
                printd(
                    f"inc - {action.src} new value {self.curr_thread.rd_register(action.src) }",
                    stage_trace,
                )
        elif "st" in action.lm_mode:
            dst_offset = self.curr_thread.rd_register(action.dst)
            # scaled_addr = dst_offset << self.rd_imm(action.imm)
            data_addr = self.curr_thread.rd_register(action.rt) + (
                dst_offset << self.rd_imm(action.imm)
            )
            src_data = int(self.curr_thread.rd_register(action.src))
            self.mmu.validate(data_addr, 8)
            self.LM.write_word(data_addr - self.scratchpad_base, src_data)
            self.metric.up_lm_write_bytes += 8
            printd(
                f"    move_word st - src {action.dst} {self.curr_thread.rd_register(action.dst)} data_addr {hex(data_addr)} "
                + f"offset {self.curr_thread.rd_register(action.rt)} data {src_data}",
                stage_trace,
                self.metric.curTimeStamp(),
            )
            if "inc" in action.lm_mode:
                self.curr_thread.wr_register(action.dst, dst_offset + 1)
                printd(
                    f"inc - {action.dst} new value {self.curr_thread.rd_register(action.dst) }",
                    stage_trace,
                )

    def do_mov_lm2sb(self, action):
        data_addr = self.curr_thread.rd_register(action.src)
        self.mmu.validate(data_addr, self.sb_size * 8)
        for i in range(0, self.sb_size, 8):
            data = self.LM.read_word(data_addr - self.scratchpad_base)
            data_addr += 8
            self.sb_stream[data_addr << 3 : (data_addr << 3) + 64] = data
        self.curr_thread.wr_register(action.src, data_addr + 8)

    def do_mov_lm2reg(self, action):
        src_addr = self.curr_thread.rd_register(action.src)
        numOfBytes = self.rd_imm(action.imm)
        self.mmu.validate(src_addr, numOfBytes)
        src_addr -= self.scratchpad_base
        if numOfBytes == 8:
            lm_data = self.LM.read_word(src_addr)
        elif numOfBytes == 4:
            lm_data = self.LM.read_4bytes(src_addr)
        elif numOfBytes == 2:
            lm_data = self.LM.read_2bytes(src_addr)
        elif numOfBytes == 1:
            lm_data = self.LM.read_byte(src_addr)
        else:
            action.printOut(error)
            exit()
        self.metric.up_lm_read_bytes += numOfBytes
        self.curr_thread.wr_register(action.dst, lm_data)

    def do_mov_reg2lm(self, action):
        src_data = int(self.curr_thread.rd_register(action.src))
        data_addr = self.curr_thread.rd_register(action.dst)
        if action.src == "X3":
            src_data = []
            for i in range(len(self.curr_thread.ops.operands)):
                src_data.append(self.curr_thread.ops.getOp(i))
            numOfBytes = len(src_data) * 8
            self.mmu.validate(data_addr, numOfBytes)
            lm_addr = data_addr - self.scratchpad_base
            for obdata in src_data:
                obdata = obdata & 0xFFFFFFFFFFFFFFFF
                self.LM.write_word(lm_addr, obdata)
                lm_addr += 8
        else:
            numOfBytes = self.rd_imm(action.imm)
            self.mmu.validate(data_addr, numOfBytes)
            lm_addr = data_addr - self.scratchpad_base
            printd(
                "mov_reg2lm: src:%s data:%d, LM_addr = %d, num_bytes:%d"
                % (action.src, src_data, lm_addr, numOfBytes),
                stage_trace,
            )
            if numOfBytes == 8:
                src_data = src_data & 0xFFFFFFFFFFFFFFFF
                self.LM.write_word(lm_addr, src_data)
            elif numOfBytes == 4:
                src_data = src_data & 0xFFFFFFFF
                self.LM.write_4bytes(lm_addr, src_data)
            elif numOfBytes == 2:
                src_data = src_data & 0xFFFF
                self.LM.write_2bytes(lm_addr, src_data)
            elif numOfBytes == 1:
                src_data = src_data & 0xFF
                self.LM.write_byte(lm_addr, src_data)
            else:
                action.printOut(error)
                exit()
        self.metric.up_lm_write_bytes += numOfBytes

    def do_mov_ear2lm(self, action):
        src_data = self.rd_ear(action.src)
        numOfBytes = self.rd_imm(action.imm)
        data_addr = self.curr_thread.rd_register(action.dst)
        self.mmu.validate(data_addr, numOfBytes)
        lm_addr = data_addr - self.scratchpad_base
        if numOfBytes == 8:
            src_word = src_data & 0xFFFFFFFFFFFFFFFF
            self.LM.write_word(lm_addr, src_word)
        else:
            action.printOut(error)
            exit()
        self.metric.up_lm_write_bytes += numOfBytes

    def do_mov_lm2ear(self, action):
        src_addr = self.curr_thread.rd_register(action.src)
        numOfBytes = self.rd_imm(action.imm)
        self.mmu.validate(src_addr, numOfBytes)
        lm_addr = src_addr - self.scratchpad_base
        if numOfBytes == 8:
            src_word = self.LM.read_word(lm_addr)
            self.wr_ear(action.dst, src_word)
        else:
            action.printOut(error)
            exit()
        self.metric.up_lm_read_bytes += numOfBytes

    def do_mov_reg2reg(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        self.curr_thread.wr_register(action.dst, src_data)

    def do_mov_eqt2reg(self, action):
        src_data = self.curr_event.event_word
        self.curr_thread.wr_register(action.dst, src_data)

    def do_mov_ob2reg(self, action):
        src_data = self.curr_thread.rd_obbuffer(action.src)
        self.curr_thread.wr_register(action.dst, src_data)

    def do_mov_ob2ear(self, action):
        data1 = self.curr_thread.rd_obbuffer(action.src)
        self.wr_ear(action.dst, data1)

    def do_ev_update_1(self, action):
        # this can only be used to update thread ID or lower bits of event_label in the new format
        src = self.curr_thread.rd_register(action.src)
        imm = self.rd_imm(action.imm)
        mask = self.rd_imm(action.imm2)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        newword = src
        # 0 - event_label, 1 - thread Id, 2 n/wID
        shiftval = {0: 0, 1: 20, 2: 24, 3: 32}
        switch = {
            0: 0xFFFFFFFFFFF00000,
            1: 0xFFFFFFFFFF8FFFFF,
            2: 0xFFFFFFFF00FFFFFF,
            3: 0x00000000FFFFFFFF,
        }
        nmask = {
            0: 0x00000000000FFFFF,
            1: 0x0000000000700000,
            2: 0x00000000FF000000,
            3: 0xFFFFFFFF00000000,
        }
        for i in range(len(masks)):
            if masks[i] == 1:
                word_mask = switch[i]
                neg_mask = nmask[i]
                newword = (newword & word_mask) | ((imm << shiftval[i]) & neg_mask)
        printd(
            "lane %s do_ev_update_1 - src %s(%s), imm %s, mask 0x%x, masks %s, newword %s"
            % (self.lane_id, action.src, src, imm, word_mask, masks, newword),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        self.curr_thread.wr_register(action.dst, newword)

    def do_ev_update_2(self, action):
        # This is probably not a use case anymore! can't update 2 immediate values now
        # discuss and potentially remove this?
        src = self.curr_event.event_word
        imm = self.rd_imm(action.op1)
        imm2 = self.rd_imm(action.op2)
        mask = self.rd_imm(action.op3)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        newword = src
        oneset = 0
        # switch = {0: 0xFFFFFF00, 1: 0xFFFF00FF, 2: 0xFF00FFFF, 3: 0x00FFFFFF}
        shiftval = {0: 0, 1: 20, 2: 24, 3: 32}
        switch = {
            0: 0xFFFFFFFFFFF00000,
            1: 0xFFFFFFFFFF8FFFFF,
            2: 0xFFFFFFFF00FFFFFF,
            3: 0x00000000FFFFFFFF,
        }
        nmask = {
            0: 0x00000000000FFFFF,
            1: 0x0000000000700000,
            2: 0x00000000FF000000,
            3: 0xFFFFFFFF00000000,
        }
        for i in range(len(masks)):
            if masks[i] == 1:
                word_mask = switch[i]
                neg_mask = nmask[i]
                if oneset == 0:
                    newword = (newword & word_mask) | (
                        ((imm & 0xFFFFFFFFFFFFFFFF) << shiftval[i]) & neg_mask
                    )
                    oneset = 1
                else:
                    newword = (newword & word_mask) | (
                        ((imm2 & 0xFFFFFFFFFFFFFFFF) << shiftval[i]) & neg_mask
                    )
        self.curr_thread.wr_register(action.dst, newword)

    def do_ev_update_reg_imm(self, action):
        src = self.curr_event.event_word
        regval = self.curr_thread.rd_register(action.dst)
        imm = self.rd_imm(action.imm)
        mask = self.rd_imm(action.imm2)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        newword = src
        oneset = 0
        # switch = {0: 0xFFFFFF00, 1: 0xFFFF00FF, 2: 0xFF00FFFF, 3: 0x00FFFFFF}
        shiftval = {0: 0, 1: 20, 2: 24, 3: 32}
        switch = {
            0: 0xFFFFFFFFFFF00000,
            1: 0xFFFFFFFFFF8FFFFF,
            2: 0xFFFFFFFF00FFFFFF,
            3: 0x00000000FFFFFFFF,
        }
        nmask = {
            0: 0x00000000000FFFFF,
            1: 0x0000000000700000,
            2: 0x00000000FF000000,
            3: 0xFFFFFFFF00000000,
        }
        for i in range(len(masks)):
            if masks[i] == 1:
                word_mask = switch[i]
                neg_mask = nmask[i]
                if oneset == 0:
                    newword = (newword & word_mask) | (
                        ((imm & 0xFFFFFFFFFFFFFFFF) << shiftval[i]) & neg_mask
                    )
                    oneset = 1
                else:
                    newword = (newword & word_mask) | (
                        ((regval & 0xFFFFFFFFFFFFFFFF) << shiftval[i]) & neg_mask
                    )
        self.curr_thread.wr_register(action.src, newword)

    def do_ev_update_reg_2(self, action):
        src = self.curr_thread.rd_register(action.src)
        regval1 = self.curr_thread.rd_register(action.op1)
        regval2 = self.curr_thread.rd_register(action.op2)
        mask = self.rd_imm(action.imm)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        newword = src
        oneset = 0
        switch = {
            0: 0xFFFFFFFFFFF00000,
            1: 0xFFFFFFFFFF8FFFFF,
            2: 0xFFFFFFFF00FFFFFF,
            3: 0x00000000FFFFFFFF,
        }
        nmask = {
            0: 0x00000000000FFFFF,
            1: 0x0000000000700000,
            2: 0x00000000FF000000,
            3: 0xFFFFFFFF00000000,
        }
        shiftval = {0: 0, 1: 20, 2: 24, 3: 32}
        # switch = {0: 0xFFFFFF00, 1: 0xFFFF00FF, 2: 0xFF00FFFF, 3: 0x00FFFFFF}
        for i in range(len(masks)):
            if masks[i] == 1:
                word_mask = switch[i]
                neg_mask = nmask[i]
                if oneset == 0:
                    newword = (newword & word_mask) | (
                        ((regval1 & 0xFFFFFFFFFFFFFFFF) << shiftval[i]) & neg_mask
                    )
                    oneset = 1
                else:
                    newword = (newword & word_mask) | (
                        ((regval2 & 0xFFFFFFFFFFFFFFFF) << shiftval[i]) & neg_mask
                    )
        self.curr_thread.wr_register(action.dst, newword)

    def do_evlb(self, action):
        dst_reg_val = self.curr_thread.rd_register(action.dst)
        imm = self.rd_imm(action.imm)
        self.curr_thread.wr_register(action.dst, dst_reg_val & (~0xF_FFFF) | (imm & 0xF_FFFF))

    def do_compare_string(self, action):
        ref_p = self.curr_thread.rd_register(action.src) << 3
        cur_p = self.curr_thread.rd_register(action.rt) << 3
        length = 0
        ref_byte = self.in_stream[ref_p : ref_p + 8]
        cur_byte = self.in_stream[cur_p : cur_p + 8]
        while ref_byte == cur_byte and length < 255:
            ref_p += 8
            cur_p += 8
            length += 1
            ref_byte = self.in_stream[ref_p : ref_p + 8]
            cur_byte = self.in_stream[cur_p : cur_p + 8]
        # ====== estimate extra cycles
        self.metric.cycle += 2 + length // 8
        self.metric.exec_cycles += 2 + length // 8
        self.curr_thread.wr_register(action.dst, length)

    def do_compare_string_from_out(self, action):
        ref_p = self.curr_thread.rd_register(action.src) << 3
        cur_p = self.curr_thread.rd_register(action.rt) << 3
        length = 0
        ref_byte = self.out_stream[ref_p : ref_p + 8]
        cur_byte = self.out_stream[cur_p : cur_p + 8]
        while ref_byte == cur_byte and length < 255:
            ref_p += 8
            cur_p += 8
            length += 1
            ref_byte = self.out_stream[ref_p : ref_p + 8]
            cur_byte = self.out_stream[cur_p : cur_p + 8]
        # ====== estimate extra cycles
        self.metric.cycle += 2 + length // 8
        self.metric.exec_cycles += 2 + length // 8
        self.curr_thread.wr_register(action.dst, length)

    def do_sub_immediate(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        imm = int(action.imm)
        res = src_data - imm
        self.curr_thread.wr_register(action.dst, res)

    def do_add_immediate(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        imm = int(action.imm)
        res = src_data + imm
        self.curr_thread.wr_register(action.dst, res)

    def do_mul_immediate(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        imm = int(action.imm)
        res = src_data * imm
        self.metric.cycle += 3
        self.metric.exec_cycles += 3
        self.curr_thread.wr_register(action.dst, res)

    def do_div_immediate(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        imm = int(action.imm)
        res = src_data // imm
        self.metric.cycle += 9
        self.metric.exec_cycles += 9
        self.curr_thread.wr_register(action.dst, res)

    def do_mod_immediate(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        imm = int(action.imm)
        res = src_data % imm
        self.metric.cycle += 9
        self.metric.exec_cycles += 9
        self.curr_thread.wr_register(action.dst, res)

    # ====== copy from [src_addr, src_addr+length) ======
    def do_copy(self, action):
        src_addr = self.curr_thread.rd_register(action.src)
        dst_addr = self.curr_thread.rd_register(action.rt)
        length = self.curr_thread.rd_register(action.dst)
        ori_length = length
        src_ptr = src_addr
        dst_ptr = dst_addr  # next line changed by Marzi
        while length > 0:
            data_byte = self.in_stream[src_ptr << 3 : (src_ptr << 3) + 8]
            self.out_stream[dst_ptr << 3 : (dst_ptr << 3) + 8] = data_byte
            src_ptr += 1
            dst_ptr += 1
            length -= 1  # next line changed by Marzi
        self.curr_thread.wr_register(action.src, src_ptr)
        self.curr_thread.wr_register(action.rt, dst_ptr)
        self.curr_thread.wr_register(action.dst, length)
        # ====== estimate extra cycles
        self.metric.cycle += 2 + ori_length // 8
        self.metric.exec_cycles += 2 + ori_length // 8

    def do_copy_ob_lm(self, action):
        src_addr = action.src
        dst_addr = self.curr_thread.rd_register(action.rt)
        # length = self.curr_thread.rd_register(action.dst)
        length = self.curr_thread.rd_register(action.dst)
        ob_data = self.curr_thread.rd_obbuffer_block(src_addr, length)
        self.mmu.validate(dst_addr, length)
        for i in range(int(length / 8)):
            self.LM.write_word(dst_addr + i * 8 - self.scratchpad_base, ob_data[i])
            self.metric.up_lm_write_bytes += 8
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

    def do_bcopy_ops(self, action):
        src_addr = action.src
        # dst_addr = self.curr_thread.rd_register(action.rt)
        # #length = self.curr_thread.rd_register(action.dst)
        # length = self.curr_thread.rd_register(action.dst)
        dst_addr = self.curr_thread.rd_register(action.dst)
        length = self.curr_thread.rd_register(action.rt)
        ob_data = self.curr_thread.rd_ops(src_addr, length)
        self.mmu.validate(dst_addr, length)
        for i in range(int(length)):
            self.LM.write_word(dst_addr + i * 8 - self.scratchpad_base, ob_data[i])
            self.metric.up_lm_write_bytes += 8
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

    def do_bcpyoli(self, action):
        src_addr = action.src
        dst_addr = self.curr_thread.rd_register(action.dst)
        length = self.rd_imm(action.imm)
        ob_data = self.curr_thread.rd_ops(src_addr, length)
        self.mmu.validate(dst_addr, length)
        for i in range(int(length)):
            self.LM.write_word(dst_addr + i * 8 - self.scratchpad_base, ob_data[i])
            self.metric.up_lm_write_bytes += 8
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

    # ====== copy from outstream [src_addr, src_addr+length) ======
    # NOTE: real UDP should have 1 copy. No matter from in stream or out stream
    def do_copy_from_out(self, action):
        src_addr = self.curr_thread.rd_register(action.src)
        dst_addr = self.curr_thread.rd_register(action.rt)
        length = self.curr_thread.rd_register(action.dst)
        ori_length = length
        src_ptr = src_addr
        dst_ptr = dst_addr  # next line changed by Marzi
        while length > 0:
            data_byte = self.out_stream[src_ptr << 3 : (src_ptr << 3) + 8]
            self.out_stream[dst_ptr << 3 : (dst_ptr << 3) + 8] = data_byte
            src_ptr += 1
            dst_ptr += 1
            length -= 1  # next line changed by Marzi
        self.curr_thread.wr_register(action.src, src_ptr)
        self.curr_thread.wr_register(action.rt, dst_ptr)
        self.curr_thread.wr_register(action.dst, length)
        # ====== estimate extra cycles
        self.metric.cycle += 2 + ori_length // 8
        self.metric.exec_cycles += 2 + ori_length // 8

    def do_sub_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src - rt
        self.curr_thread.wr_register(action.dst, res)

    def do_add_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src + rt
        self.curr_thread.wr_register(action.dst, res)

    # Mul - 4 cycles, Div, Mod - 10 cycles
    def do_mul_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src * rt
        self.metric.cycle += 3
        self.metric.exec_cycles += 3
        self.curr_thread.wr_register(action.dst, res)

    def do_div_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src // rt
        self.metric.cycle += 9
        self.metric.exec_cycles += 9
        self.curr_thread.wr_register(action.dst, res)

    def do_mod_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src % rt
        self.metric.cycle += 9
        self.metric.exec_cycles += 9
        self.curr_thread.wr_register(action.dst, res)

    def do_bitclr_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src & ~(1 << rt)
        self.curr_thread.wr_register(action.dst, res)

    def do_bitset_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src | (1 << rt)
        self.curr_thread.wr_register(action.dst, res)

    def do_put2byte_imm(self, action):
        data = self.rd_imm(action.imm)
        lm_addr_orig = self.curr_thread.rd_register(action.src)
        numOfBytes = 2
        self.mmu.validate(lm_addr_orig, numOfBytes)
        lm_addr = lm_addr_orig - self.scratchpad_base
        data = data & 0xFFFF
        self.LM.write_byte(lm_addr, data)
        lm_addr_orig += 2
        self.curr_thread.wr_register(action.src, lm_addr_orig)
        self.metric.cycle += 1
        self.metric.exec_cycles += 1

    def do_put1byte_imm(self, action):
        data = self.rd_imm(action.imm)
        lm_addr_orig = self.curr_thread.rd_register(action.src)
        numOfBytes = 1
        self.mmu.validate(lm_addr_orig, numOfBytes)
        lm_addr = lm_addr_orig - self.scratchpad_base
        data = data & 0xFF
        self.LM.write_byte(lm_addr, data)
        lm_addr_orig += 1
        self.curr_thread.wr_register(action.src, lm_addr_orig)
        self.metric.cycle += 1
        self.metric.exec_cycles += 1

    def do_lshift_add_imm(self, action):
        src = self.curr_thread.rd_register(action.src)
        add_val = self.rd_imm(action.imm2)
        shift_val = int(action.imm)
        res = ((src << shift_val) & 0xFFFFFFFFFFFFFFFF) + add_val
        self.curr_thread.wr_register(action.dst, res)

    def do_rshift_add_imm(self, action):
        src = self.curr_thread.rd_register(action.src)
        add_val = self.rd_imm(action.imm2)
        shift_val = int(action.imm)
        res = (src >> shift_val) + add_val
        self.curr_thread.wr_register(action.dst, res)

    def do_lshift_and_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        and_val = 0xFFFFFFFFFFFFFFFF & self.rd_imm(action.imm2)
        shift_val = 0xFFFFFFFFFFFFFFFF & int(action.imm)
        res = ((src << shift_val) & 0xFFFFFFFFFFFFFFFF) & and_val
        self.curr_thread.wr_register(action.dst, res)

    def do_rshift_and_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        and_val = 0xFFFFFFFFFFFFFFFF & self.rd_imm(action.imm2)
        shift_val = 0xFFFFFFFFFFFFFFFF & int(action.imm)
        res = (src >> shift_val) & and_val
        self.curr_thread.wr_register(action.dst, res)

    def do_lshift_or_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        or_val = 0xFFFFFFFFFFFFFFFF & self.rd_imm(action.imm2)
        shift_val = 0xFFFFFFFFFFFFFFFF & int(action.imm)
        res = ((src << shift_val) & 0xFFFFFFFFFFFFFFFF) | or_val
        self.curr_thread.wr_register(action.dst, res)

    def do_rshift_or_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        or_val = 0xFFFFFFFFFFFFFFFF & self.rd_imm(action.imm2)
        shift_val = 0xFFFFFFFFFFFFFFFF & int(action.imm)
        res = (src >> shift_val) | or_val
        self.curr_thread.wr_register(action.dst, res)

    def do_putbits(self, action):
        data = int(action.imm2)
        length = int(action.imm)
        src_ptr = self.curr_thread.rd_register(action.src)
        src_byte_addr_orig = src_ptr >> 3
        numOfBytes = 2
        self.mmu.validate(src_byte_addr_orig, numOfBytes)
        src_byte_addr = src_byte_addr_orig - self.scratchpad_base
        lm_data = self.LM.read_2bytes(src_byte_addr)
        mod = src_ptr % 8
        lm_data = (
            (lm_data & ((2**mod) - 1))
            | (data << mod)
            | (lm_data & (~((2 ** (mod + length + 1)) - 1)))
        )
        self.LM.write_word(src_byte_addr_orig, lm_data)

    def do_getbits(self, action):
        length = int(action.imm)
        src_ptr = self.curr_thread.rd_register(action.src)
        src_byte_addr_orig = src_ptr >> 3
        numOfBytes = 2
        self.mmu.validate(src_byte_addr_orig, numOfBytes)
        src_byte_addr = src_byte_addr_orig - self.scratchpad_base
        lm_data = self.LM.read_2bytes(src_byte_addr)
        mod = src_ptr % 8
        data = (int(lm_data) & (~((2 ** (mod + length + 1)) - 1))) >> mod
        self.curr_thread.wr_register(action.dst, data)

    def do_putbytes(self, action):
        src_data = self.curr_thread.rd_register(action.src)
        numOfBytes = int(action.imm)
        lm_addr_orig = self.curr_thread.rd_register(action.dst)
        self.mmu.validate(lm_addr_orig, numOfBytes)
        lm_addr = lm_addr_orig - self.scratchpad_base
        printd(
            "putbytes: data:%d, LM_addr = %d, num_bytes:%d"
            % (src_data, lm_addr_orig, numOfBytes),
            stage_trace,
        )
        if numOfBytes == 8:
            src_data = src_data & 0xFFFFFFFFFFFFFFFF
            self.LM.write_word(lm_addr, src_data)
            lm_addr_orig += 8
        elif numOfBytes == 4:
            src_data = src_data & 0xFFFFFFFF
            self.LM.write_4bytes(lm_addr, src_data)
            lm_addr_orig += 4
        elif numOfBytes == 2:
            src_data = src_data & 0xFFFF
            self.LM.write_2bytes(lm_addr, src_data)
            lm_addr_orig += 2
        elif numOfBytes == 1:
            src_data = src_data & 0xFF
            self.LM.write_byte(lm_addr, src_data)
            lm_addr_orig += 1
        else:
            print("the number of bytes is not supported! "),
            action.printOut(error)
            exit()
        self.metric.up_lm_write_bytes += numOfBytes

        self.curr_thread.wr_register(action.dst, lm_addr_orig)

    def do_compare_less_than(self, action):
        src = self.curr_thread.rd_register(action.src)
        imm = self.rd_imm(action.imm)
        if src < imm:
            res = 1
        else:
            res = 0
        self.curr_thread.wr_register(action.dst, res)

    def do_compare_great_than(self, action):
        src = self.curr_thread.rd_register(action.src)
        imm = self.rd_imm(action.imm)
        if src > imm:
            res = 1
        else:
            res = 0
        self.curr_thread.wr_register(action.dst, res)

    def do_compare_equal(self, action):
        src = self.curr_thread.rd_register(action.src)
        imm = self.rd_imm(action.imm)
        if src == imm:
            res = 1
        else:
            res = 0
        self.curr_thread.wr_register(action.dst, res)

    def do_compare_reg(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src - rt
        self.curr_thread.wr_register(action.dst, res)

    def do_compare_reg_equal(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        if src == rt:
            res = 1
        else:
            res = 0
        self.curr_thread.wr_register(action.dst, res)

    def do_compare_reg_less_than(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        if src < rt:
            res = 1
        else:
            res = 0
        self.curr_thread.wr_register(action.dst, res)

    def do_compare_reg_great_than(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        if src > rt:
            res = 1
        else:
            res = 0
        self.curr_thread.wr_register(action.dst, res)

    def do_bitwise_xor(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        rt = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.rt)
        dst = rt ^ src
        self.curr_thread.wr_register(action.dst, dst)

    def do_bitwise_or(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        rt = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.rt)
        dst = rt | src
        self.curr_thread.wr_register(action.dst, dst)

    def do_bitwise_and(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        rt = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.rt)
        dst = rt & src
        self.curr_thread.wr_register(action.dst, dst)

    def do_lshift_or(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        dst = dst | ((src << shift) & 0xFFFFFFFFFFFFFFFF)
        self.curr_thread.wr_register(action.dst, dst)

    def do_lshift_and(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        dst = dst & ((src << shift) & 0xFFFFFFFFFFFFFFFF)
        self.curr_thread.wr_register(action.dst, dst)

    def do_lshift(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        dst = (src << shift) & 0xFFFFFFFFFFFFFFFF
        self.curr_thread.wr_register(action.dst, dst)

    def do_rshift_or(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        res = dst | (src >> shift)
        self.curr_thread.wr_register(action.dst, res)

    def do_rshift_and(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        res = dst & (src >> shift)
        self.curr_thread.wr_register(action.dst, res)

    def do_rshift(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        #### PATCH FIX TODO 0xFFFF... >> 1 should equal 0x7FFF...
        dst = (src & 0xFFFFFFFFFFFFFFFF) >> shift
        self.curr_thread.wr_register(action.dst, dst)

    def do_rshift_t(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.rt)
        shift = min(max(0, shift), 64)
        dst = src >> shift
        self.curr_thread.wr_register(action.dst, dst)

    def do_lshift_t(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.rt)
        shift = min(max(0, shift), 64)
        dst = (src << shift) & 0xFFFFFFFFFFFFFFFF
        self.curr_thread.wr_register(action.dst, dst)

    def do_arithrshift(self, action):  # added by Marziyeh (arithrshifts)
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = self.rd_imm(action.imm)
        shift = min(max(0, shift), 64)
        dst = arithmetic_rshift(src, 64, shift)  # Marziyeh to fix this
        self.curr_thread.wr_register(action.dst, dst)

    def do_arithrshift_t(self, action):  # added by Marziyeh (arithrshifts)
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        dst = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.dst)
        shift = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.rt)
        shift = min(max(0, shift), 64)
        dst = arithmetic_rshift(src, 64, shift)  # Marziyeh to fix this
        self.curr_thread.wr_register(action.dst, dst)

    def do_getbytes(self, action):
        src_ptr = self.curr_thread.rd_register(action.src)
        numOfBytes = self.rd_imm(action.imm)
        if numOfBytes == 4:
            # ====== align read and unalign read
            if src_ptr % 4 == 0:
                self.metric.cycle += 1
                self.metric.exec_cycles += 1
            else:
                self.metric.cycle += 2
                self.metric.exec_cycles += 2

            data = self.in_stream[src_ptr << 3 : (src_ptr << 3) + 32]
            src_ptr += 4
            data = data.tobytes()
            res = 0
            for i in range(0, 4):
                res |= (data[i]) << (
                    i * 8
                )  # changed by Marzi due to Machin's endian's discrepency

        elif numOfBytes == 3:
            # ====== align read and unalign read
            if src_ptr % 4 == 0 or src_ptr % 4 == 1:
                self.metric.cycle += 1
                self.metric.exec_cycles += 1
            else:
                self.metric.cycle += 2
                self.metric.exec_cycles += 2

            data = self.in_stream[src_ptr << 3 : (src_ptr << 3) + 24]
            src_ptr += 3
            data = data.tobytes()
            res = 0
            for i in range(0, 3):  # 2): #changed by Marzi (I think this was incorrect)
                res |= (data[i]) << (
                    i * 8
                )  # changed by Marzi due to Machin's endian's discrepency

        elif numOfBytes == 2:
            # ====== align read and unalign read
            if src_ptr % 4 == 0 or src_ptr % 4 == 1 or src_ptr % 4 == 2:
                self.metric.cycle += 1
                self.metric.exec_cycles += 1
            else:
                self.metric.cycle += 2
                self.metric.exec_cycles += 2
            data = self.in_stream[src_ptr << 3 : (src_ptr << 3) + 16]
            src_ptr += 2
            data = data.tobytes()
            res = 0
            for i in range(0, 2):
                res |= (data[i]) << (
                    i * 8
                )  # changed by Marzi due to Machin's endian's discrepency

        elif numOfBytes == 1:
            # ====== align read
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

            data = self.in_stream[src_ptr << 3 : (src_ptr << 3) + 8]
            src_ptr += 1
            data = data.tobytes()
            res = data[0]

        self.curr_thread.wr_register(action.src, src_ptr)
        self.curr_thread.wr_register(action.dst, res)

    def do_getbytes_from_out(self, action):
        src_ptr = self.curr_thread.rd_register(action.src)
        numOfBytes = self.rd_imm(action.imm)
        if numOfBytes == 4:
            # ====== align read and unalign read
            if src_ptr % 4 == 0:
                self.metric.cycle += 1
                self.metric.exec_cycles += 1
            else:
                self.metric.cycle += 2
                self.metric.exec_cycles += 2

            data = self.out_stream[src_ptr << 3 : (src_ptr << 3) + 32]
            src_ptr += 4
            data = data.tobytes()
            res = 0
            for i in range(0, 4):
                res |= (data[3 - i]) << (i * 8)

        elif numOfBytes == 3:
            # ====== align read and unalign read
            if src_ptr % 4 == 0 or src_ptr % 4 == 1:
                self.metric.cycle += 1
                self.metric.exec_cycles += 1
            else:
                self.metric.cycle += 2
                self.metric.exec_cycles += 2

            data = self.out_stream[src_ptr << 3 : (src_ptr << 3) + 24]
            src_ptr += 3
            data = data.tobytes()
            res = 0
            for i in range(0, 3):  # 2): #changed by Marzi (I think this was incorrect)
                res |= (data[2 - i]) << (i * 8)

        elif numOfBytes == 2:
            # ====== align read and unalign read
            if src_ptr % 4 == 0 or src_ptr % 4 == 1 or src_ptr % 4 == 2:
                self.metric.cycle += 1
                self.metric.exec_cycles += 1
            else:
                self.metric.cycle += 2
                self.metric.exec_cycles += 2

            data = self.out_stream[src_ptr << 3 : (src_ptr << 3) + 16]
            src_ptr += 2
            data = data.tobytes()
            res = 0
            for i in range(0, 2):
                res |= (data[1 - i]) << (i * 8)

        elif numOfBytes == 1:
            # ====== align read
            self.metric.cycle += 1
            self.metric.exec_cycles += 1

            data = self.out_stream[src_ptr << 3 : (src_ptr << 3) + 8]
            src_ptr += 1
            data = data.tobytes()
            res = data[0]

        self.curr_thread.wr_register(action.src, src_ptr)
        self.curr_thread.wr_register(action.dst, res)

    def do_rshift_sub_imm(self, action):
        src = self.curr_thread.rd_register(action.src)
        sub_val = self.rd_imm(action.imm2)
        shift_val = int(action.imm)
        res = (src >> shift_val) - sub_val
        self.curr_thread.wr_register(action.dst, res)

    def do_lshift_sub_imm(self, action):
        src = self.curr_thread.rd_register(action.src)
        sub_val = self.rd_imm(action.imm2)
        shift_val = self.rd_imm(action.imm)
        res = ((src << shift_val) & 0xFFFFFFFFFFFFFFFF) - sub_val
        self.curr_thread.wr_register(action.dst, res)

    def do_cmpswp_i(self, action):
        mem_addr = self.curr_thread.rd_register(action.dst)
        self.mmu.validate(mem_addr, 8)
        mem_addr -= self.scratchpad_base
        mem = self.LM.read_word(mem_addr)
        self.metric.up_lm_read_bytes += 8
        if mem == self.rd_imm(action.imm):
            self.LM.write_word(mem_addr, self.rd_imm(action.imm2))
        self.metric.up_lm_write_bytes += 8
        self.curr_thread.wr_register(action.src, mem)

    def do_cmpswp_ri(self, action):
        mem_addr = self.curr_thread.rd_register(action.dst)
        self.mmu.validate(mem_addr, 8)
        mem_addr -= self.scratchpad_base
        mem = self.LM.read_word(mem_addr)
        old_val = self.curr_thread.rd_register(action.imm)
        self.metric.up_lm_read_bytes += 8
        if mem == old_val:
            self.LM.write_word(mem_addr, self.rd_imm(action.imm2))
        self.metric.up_lm_write_bytes += 8
        self.curr_thread.wr_register(action.src, mem)

    def do_cmpswp(self, action):
        mem_addr = self.curr_thread.rd_register(action.dst)
        self.mmu.validate(mem_addr, 8)
        mem_addr -= self.scratchpad_base
        mem = self.LM.read_word(mem_addr)
        self.metric.up_lm_read_bytes += 8
        old_val = self.curr_thread.rd_register(action.op1)
        new_val = self.curr_thread.rd_register(action.op2)
        if mem == old_val:
            self.LM.write_word(mem_addr, new_val)
        self.metric.up_lm_write_bytes += 8
        self.curr_thread.wr_register(action.src, mem)

    def do_bitwise_and_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        mask = 0xFFFFFFFFFFFFFFFF & self.rd_imm_u(action.imm)
        res = src & mask
        self.curr_thread.wr_register(action.dst, res)

    def do_bitwise_or_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        mask = 0xFFFFFFFFFFFFFFFF & self.rd_imm_u(action.imm)
        res = src | mask
        self.curr_thread.wr_register(action.dst, res)

    def do_bitwise_xor_imm(self, action):
        src = 0xFFFFFFFFFFFFFFFF & self.curr_thread.rd_register(action.src)
        imm = 0xFFFFFFFFFFFFFFFF & self.rd_imm_u(action.imm)
        res = src ^ imm
        self.curr_thread.wr_register(action.dst, res)

    # ====== copy from [src_addr, src_addr+length) ======
    def do_copy_imm(self, action):
        src_addr = self.curr_thread.rd_register(action.src)
        dst_addr = self.curr_thread.rd_register(action.dst)
        length = self.rd_imm(action.imm)
        ori_length = length
        src_ptr = src_addr
        dst_ptr = dst_addr
        while length > 0:
            data_byte = self.in_stream[src_ptr << 3 : (src_ptr << 3) + 8]
            self.out_stream[dst_ptr << 3 : (dst_ptr << 3) + 8] = data_byte
            src_ptr += 1
            dst_ptr += 1
            length -= 1  # next line Marzi changed
        self.curr_thread.wr_register(action.src, src_ptr)
        self.curr_thread.wr_register(action.dst, dst_ptr)
        # ====== estimate extra cycles
        self.metric.cycle += 2 + ori_length // 8
        self.metric.exec_cycles += 2 + ori_length // 8

    # ====== copy from [src_addr, src_addr+length) ======
    def do_copy_from_out_imm(self, action):
        src_addr = self.curr_thread.rd_register(action.src)
        dst_addr = self.curr_thread.rd_register(action.dst)
        length = self.rd_imm(action.imm)
        ori_length = length
        src_ptr = src_addr
        dst_ptr = dst_addr
        while length > 0:
            data_byte = self.out_stream[src_ptr << 3 : (src_ptr << 3) + 8]
            self.out_stream[dst_ptr << 3 : (dst_ptr << 3) + 8] = data_byte
            src_ptr += 1
            dst_ptr += 1
            length -= 1  # next line Marzi changed
        self.curr_thread.wr_register(action.src, src_ptr)
        self.curr_thread.wr_register(action.dst, dst_ptr)
        # ====== estimate extra cycles
        self.metric.cycle += 2 + ori_length // 8
        self.metric.exec_cycles += 2 + ori_length // 8

    # Who uses this? - Andronicus to find out not in the ISA spec
    def do_swap_bytes(self, action):
        data = self.curr_thread.rd_register(action.src)
        numOfbytes = self.rd_imm(action.imm)
        if numOfbytes == 2:
            high = (data >> 8) & 0xFF
            low = data & 0xFF
            swaped = low << 8 | high
            self.curr_thread.wr_register(action.dst, swaped)
        else:
            action.printOut(error)

    def do_mask_or(self, action):
        src = self.curr_thread.rd_register(action.src)
        mask = self.rd_imm(action.imm)
        dst = self.curr_thread.rd_register(action.dst)
        data = (src & mask) | dst
        self.curr_thread.wr_register(action.dst, data)

    def do_goto(self, action):
        # ====== it is a virtual action that does the "goto"
        # the transition primitive actually does the "goto" address in the attach
        # it is used for transitions whose all actions are in the same shared action block
        if action.opcode == "tranCarry_goto":
            self.metric.cycle -= 1
            self.metric.exec_cycles -= 1

        block_id = action.imm
        if block_id not in self.program.sharedBlock:
            action.printOut(error)
            exit()

        action_list = self.program.sharedBlock[block_id]
        dst_property = None
        forked_activations = None
        yield_exec = 0
        yield_term = 0
        seqnum = 0
        # ====== execute each action in the block
        while yield_exec == 0 and seqnum <= len(action_list):
            # ====== action can modify the destination state's
            # property, and fork multiple activations ======
            # actions execute until you hit a yield
            shared_act = action_list[seqnum]
            (
                action_dst_property,
                forked_activations,
                yield_exec,
                next_seqnum,
                yield_term,
            ) = self.actionHandler(shared_act, seqnum)
            # branch instructions could've changed the seqnum
            seqnum = next_seqnum
            # ====== if action changes the property, we need to
            # apply it to destination state ======
            if action_dst_property is not None:
                dst_property = action_dst_property
        return dst_property, forked_activations, yield_exec, yield_term

    def do_set_issue_width(self, action):
        new_width = self.rd_imm(action.imm)
        # Changes by Marzi
        self.curr_thread.CR_Issue = new_width
        old_CR_Advance = self.curr_thread.CR_Advance
        self.curr_thread.CR_Advance = new_width
        # the SBP should commit the old_CR_Advance, we compensate here
        # Changes by Marzi
        self.curr_thread.SBP += old_CR_Advance - self.curr_thread.CR_Advance

    def do_set_complete(self, action):
        imm = self.rd_imm(action.imm)
        if imm == 1:
            self.curr_thread.SBP = self.curr_thread.getInStreamBits() + 1  # Marzi

    def do_refill(self, action):
        # it is a virutal action. In machine code, it is represented in transition
        # primitive
        self.metric.cycle -= 1
        self.metric.exec_cycles -= 1
        flush = self.rd_imm(action.imm)
        self.curr_thread.SBP = self.curr_thread.SBP - flush  # Marzi

    def do_mov_imm2reg(self, action):
        imm = self.rd_imm(action.imm)
        self.curr_thread.wr_register(action.dst, imm)

    def do_mov_sb2reg(self, action):  # added by Marzi
        issue_data = self.sb_stream[
            self.curr_thread.SBP : self.curr_thread.SBP + self.curr_thread.CR_Issue
        ].bin  # Marzi
        issue_data = self.bitsToInt(issue_data)
        self.curr_thread.wr_register(action.dst, issue_data)

    def do_branch(self, action):
        dst_property = None
        forked_activations = None
        yield_exec = 0
        yield_term = 0
        seqnum_set = 0
        funct = action.funct
        if action.op1_ob_or_reg == 0:
            op1 = self.curr_thread.rd_obbuffer(action.op1)
        else:
            op1 = self.curr_thread.rd_register(action.op1)
        if action.op2_ob_or_reg_or_imm == 0:
            op2 = self.curr_thread.rd_obbuffer(action.op2)
        elif action.op2_ob_or_reg_or_imm == 1:
            op2 = self.curr_thread.rd_register(action.op2)
        else:
            # PATCH FIX TODO
            op2 = sign(action.op2, 5)  # Imm Value
        if action.unsigned:
            op1 = int(op1) & 0xFFFFFFFFFFFFFFFF
            if action.op2_ob_or_reg_or_imm == 1:
                op2 = int(op2) & 0xFFFFFFFFFFFFFFFF
            else:
                op2 = int(op2) & 0x1F
        else:
            # PATCH FIX TODO
            op1 = sign(op1, 64)
            op2 = int(op2)
        cond_check = False
        # Written using separate clauses for clarity # signed values
        if (
            funct == "bne"
            or funct == "bnec"
            or funct == "bnei"
            or funct == "bneu"
            or funct == "bneiu"
        ):
            if op1 != op2:
                cond_check = True
        elif (
            funct == "beq"
            or funct == "beqc"
            or funct == "beqi"
            or funct == "bequ"
            or funct == "beqiu"
        ):
            if op1 == op2:
                cond_check = True
        elif (
            funct == "ble"
            or funct == "blec"
            or funct == "blei"
            or funct == "bleu"
            or funct == "bleiu"
        ):
            if op1 <= op2:
                cond_check = True
        elif (
            funct == "blt"
            or funct == "bltc"
            or funct == "blti"
            or funct == "bltu"
            or funct == "bltiu"
        ):
            if op1 < op2:
                cond_check = True
        elif (
            funct == "bge"
            or funct == "bgec"
            or funct == "bgei"
            or funct == "bgeu"
            or funct == "bgeiu"
        ):
            if op1 >= op2:
                cond_check = True
        elif (
            funct == "bgt"
            or funct == "bgtc"
            or funct == "bgti"
            or funct == "bgtu"
            or funct == "bgtiu"
        ):
            if op1 > op2:
                cond_check = True
        else:
            print("Condition %s not supported in branches" % funct)

        if cond_check == True:
            if action.dst_issb == 1:
                next_seqnum = 0
                seqnum_set = 0
                pseudo_action = IAction(
                    "tranCarry_goto", "Empty", "Empty", action.dst, None, 1
                )
                dst_property, forked_activations, yield_exec, yield_term = self.do_goto(
                    pseudo_action
                )
            else:
                next_seqnum = int(action.dst)
                seqnum_set = 1
        else:
            next_seqnum = 0
            seqnum_set = 0
        return (
            next_seqnum,
            seqnum_set,
            dst_property,
            forked_activations,
            yield_exec,
            yield_term,
        )

    def do_jmp(self, action):
        dst_property = None
        forked_activations = None
        yield_exec = 0
        yield_term = 0
        seqnum_set = 0
        if action.dst_issb == 1:
            next_seqnum = 0
            seqnum_set = 0
            pseudo_action = IAction(
                "tranCarry_goto", "Empty", "Empty", action.dst, None, 1
            )
            dst_property, forked_activations, yield_exec, yield_term = self.do_goto(
                pseudo_action
            )
        else:
            next_seqnum = int(action.dst)
            seqnum_set = 1
        return (
            next_seqnum,
            seqnum_set,
            dst_property,
            forked_activations,
            yield_exec,
            yield_term,
        )

        # Andronicus to continue from here

        """
        32bit send
        Addr_Mode                 |  Description                                        | Pseudo Instr
        mode[0]| mode[1]| mode[2] |
        (dest) | (ret)  | (ld/st) |  Description                                        | Pseudo Instr
        4      | 0      | X       |  send_wcontinuation cases                           | send_wcont/send4_wcont
        4      | 1      | X       |  send_wret (leave out lane/TID)                     | send_wret/send4_wret
        0,1,2,3| 0      | 0       |  load data from stream ptr(DRAM) to diff lane       | send_dmlm_ld                  [mode[0] = 2,3,4,5]
        0,1,2,3| 1      | 0       |  load data from stream ptr(DRAM) to same lane       | send_dmlm_ld_wret             [mode[0] = 2,3,4,5]
        0,1,2,3| 0      | 1       |  store data at stream ptr, send ack to diff lane    | send_dmlm/send4_dmlm          [mode[0] = 2,3,4,5]
        0,1,2,3| 1      | 1       |  store data at stream ptr, send ack to same lane    | send_dmlm_wret/send4_dmlm_wret[mode[0] = 2,3,4,5]
        _ _ _ _ _
        cont | ld/st | ret | mode[0] | mode[0]

        """

    def send_basic(
        self,
        event,
        dest,
        cont,
        op1,
        op2,
        mode_0,
        mode_1,
        mode_2,
        s4,
        size=0,
        sendops=False,
        op3=None,
    ):
        """
        Addr_Mode                 |  Description                                   | Pseudo Instr
        mode[0]| mode[1]| mode[2] |
        (dest) | (ret)  | (ld/st) |  Description                                   | Pseudo Instr
        1      | 0      | X       |  send_wcontinuation cases                      | send_wcont/send4_wcont
        1      | 1      | X       |  send_wret (leave out lane/TID)                | send_wret/send4_wret
        0      | 0      | 0       |  load data from dest ptr(DRAM) to diff lane    | send_dmlm_ld
        0      | 1      | 0       |  load data from dest ptr(DRAM) to same lane    | send_dmlm_ld_wret
        0      | 0      | 1       |  store data at dest ptr, send ack to diff lane | send_dmlm/send4_dmlm
        0      | 1      | 1       |  store data at dest ptr, send ack to same lane | send_dmlm_wret/send4_dmlm_wret
        _ _ _ _ _
        cont | ld/st | ret | mode[0] | mode[0]

        """

        if self.upproc.perf_log_internal_enable:
            self.metric.write_perf_log(
                0,
                self.lane_id,
                self.curr_thread.tid,
                self.curr_event.event_base,
                self.curr_event.event_label,
                set(
                    [
                        PerfLogPayload.UD_ACTION_STATS.value,
                        PerfLogPayload.UD_TRANS_STATS.value,
                        PerfLogPayload.UD_QUEUE_STATS.value,
                        PerfLogPayload.UD_LOCAL_MEM_STATS.value,
                        PerfLogPayload.UD_MEM_INTF_STATS.value,
                    ]
                ),
            )

        # cont = self.curr_thread.rd_register(cont)
        if self.sim:
            self.send_mm.seek(0)
            self.num_sends += 1
            val = struct.pack("I", self.num_sends)
            self.send_mm.write(val)
            self.send_mm.seek(self.mm_offset)

        printd(
            "  Send_basic Modes: Mode_0:%d, Mode_1:%d, Mode_2:%d"
            % (mode_0, mode_1, mode_2),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        printd(
            "  Send_basic Operands: Event:0x%x, Dest:%d, Cont:%s, Op1:%s, Op2:%s, s4:%d"
            % (event if event is not None else 0, dest, str(cont), op1, op2, s4),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        if mode_1 == 1:
            # send with return
            # cont = (int(cont) & 0x0000FFFF) | ((self.lane_id << 24) & 0xFF000000) | ((self.curr_thread.tid << 16) & 0x00FF0000)
            cont = (
                (int(cont) & 0x000000000000FFFFF)
                | ((self.network_id << 32) & 0xFFFFFFFF00000000)
                | ((self.curr_thread.tid << 24) & 0x00000000FF000000)
            )

        next_event = None
        ev_operands = []
        if mode_0 == 1:
            # Inter lane communication mainly
            # To do update with upto 3 data values
            event_label = event & 0x00000000000FFFFF
            event_tid = (event & 0x00000000FF000000) >> 24
            thread_mode = (event & 0x0000000000800000) >> 23
            dest_network_id = dest
            if s4:
                if not sendops:
                    data1 = self.curr_thread.rd_register(op1)
                    ev_operands.append(data1)
                    if size > 1:
                        data2 = self.curr_thread.rd_register(op2)
                        ev_operands.append(data2)
                        # next_event = Event(event_label, 2)
                    if size > 2:
                        data3 = self.curr_thread.rd_register(op3)
                        ev_operands.append(data3)
                        # next_event = Event(event_label, 2)
                    # else:
                    #    # to be disallowed? adding same operand for now
                    #    ev_operands.append(data1)
                    #    #next_event = Event(event_label, 2)
                else:
                    # size = self.curr_thread.rd_register(op2)
                    size = int(op2)  # self.curr_thread.rd_register(op2)
                    srcdata = self.curr_thread.rd_ops(op1, size)
                    for data in srcdata:
                        ev_operands.append(data)
                        self.metric.cycle += 1
                        self.metric.exec_cycles += 1
                next_event = Event(event_label, size)
                size = len(ev_operands) * 8
                next_event.setnetworkid(dest_network_id)
                next_event.setthreadid(event_tid)
                next_event.setmode(thread_mode)
            else:
                size = int(op2) * 8  # New design is words
                if op1 != "UDPR_X":
                    data_addr = self.curr_thread.rd_register(op1)  # data from Rw
                    self.mmu.validate(data_addr, size)
                    lm_addr = data_addr - self.scratchpad_base
                for i in range(int(size / 8)):
                    ev_operands.append(self.LM.read_word(lm_addr + 8 * i))
                    self.metric.cycle += 1
                    self.metric.exec_cycles += 1
                next_event = Event(event_label, int(size / 8))
                next_event.setnetworkid(dest_network_id)
                next_event.setthreadid(event_tid)
                next_event.setmode(thread_mode)
            if self.sim:
                mode = (
                    (((mode_2 & 0x1) << 2) & 0x4)
                    | (((mode_1 & 0x1) << 1) & 0x2)
                    | (((mode_0 & 0x1)) & 0x1)
                ) & 0x7
                printd(
                    f"  lane {self.network_id} send_basic - mode: %d, exec_cycle: %d, next_event_word: %d, lane_num: %d cont_word: %d, size: %d"
                    % (
                        mode,
                        self.metric.cycle - self.metric.curr_event_scyc,
                        next_event.event_word,
                        dest_network_id,
                        cont,
                        size,
                    ),
                    stage_trace,
                    self.metric.curTimeStamp(),
                )
                val = struct.pack("I", mode)
                self.send_mm.write(val)
                val = struct.pack("I", self.metric.cycle - self.metric.curr_event_scyc)
                self.send_mm.write(val)
                event_word_low = next_event.event_word & 0xFFFFFFFF
                val = struct.pack("I", event_word_low)
                self.send_mm.write(val)
                event_word_high = (next_event.event_word & 0xFFFFFFFF00000000) >> 32
                val = struct.pack("I", event_word_high)
                self.send_mm.write(val)
                val = struct.pack("I", dest_network_id & 0xFFFFFFFF)
                self.send_mm.write(val)
                val = struct.pack("I", (dest_network_id & 0xFFFFFFFF00000000) >> 32)
                self.send_mm.write(val)
                val = struct.pack("I", cont & 0xFFFFFFFF)
                self.send_mm.write(val)
                val = struct.pack("I", (cont & 0xFFFFFFFF00000000) >> 32)
                self.send_mm.write(val)
                val = struct.pack("I", size)
                self.send_mm.write(val)
                for value in ev_operands:
                    val = struct.pack("I", value & 0xFFFFFFFF)
                    self.send_mm.write(val)
                    val = struct.pack("I", (value & 0xFFFFFFFF00000000) >> 32)
                    self.send_mm.write(val)
                self.mm_offset = self.send_mm.tell()

        # elif mode_0 < 4:
        else:
            # Target is global Address (LM or DRAM)
            # ear_base = "EAR_" + str(mode_0)
            event_label = cont & 0x00000000000FFFFF
            event_tid = (cont & 0xFF000000) >> 24
            dest_network_id = (cont & 0xFFFFFFFF00000000) >> 32
            dram_addr = dest
            if mode_2 == 0:
                # Load cases
                size = int(op2) * 8
                next_event = Event(event_label, int(size / 8) + 1)
                next_event.setnetworkid(dest_network_id)
                next_event.setthreadid(event_tid)
            elif mode_2 == 1:
                # Store cases
                dram_addr = dest
                if s4:
                    if sendops:
                        size = int(op2)
                        srcdata = self.curr_thread.rd_ops(op1, size)
                        for data in srcdata:
                            ev_operands.append(data)
                            self.metric.cycle += 1
                            self.metric.exec_cycles += 1
                    else:
                        data1 = self.curr_thread.rd_register(op1)
                        ev_operands.append(data1)
                        if size > 1:
                            data2 = self.curr_thread.rd_register(op2)
                            ev_operands.append(data2)
                        if size > 2:
                            data3 = self.curr_thread.rd_register(op3)
                            ev_operands.append(data3)
                    size = len(ev_operands) * 8
                else:
                    size = int(op2) * 8
                    data_addr = self.curr_thread.rd_register(op1)  # data from Rw
                    self.mmu.validate(data_addr, size)
                    lm_addr = data_addr - self.scratchpad_base
                    for i in range(int(size / 8)):
                        ev_operands.append(self.LM.read_word(lm_addr + 8 * i))
                        self.metric.cycle += 1
                        self.metric.exec_cycles += 1
                next_event = Event(event_label, len(ev_operands))
                next_event.setnetworkid(dest_network_id)
                next_event.setthreadid(event_tid)
            mode = (
                (((mode_2 & 0x1) << 2) & 0x4)
                | (((mode_1 & 0x1) << 1) & 0x2)
                | (((mode_0 & 0x1)) & 0x1)
            ) & 0x7
            next_event_word = next_event.event_word
            printd(
                f"  send_basic - mode: %d, exec_cycle: %d, next_event_word: %d, dram_addr: 0x%lx, lane_num: %d cont_word: %d, size: %d"
                % (
                    mode,
                    self.metric.cycle - self.metric.curr_event_scyc,
                    next_event_word,
                    dram_addr,
                    dest_network_id,
                    cont,
                    size,
                ),
                stage_trace,
                self.metric.curTimeStamp(),
            )
            if self.sim:
                mode = (
                    (((mode_2 & 0x1) << 2) & 0x4)
                    | (((mode_1 & 0x1) << 1) & 0x2)
                    | (((mode_0 & 0x1)) & 0x1)
                ) & 0x7
                self.metric.up_dram_bytes += size
                val = struct.pack("I", mode)
                self.send_mm.write(val)
                val = struct.pack("I", self.metric.cycle - self.metric.curr_event_scyc)
                self.send_mm.write(val)
                next_event_word = next_event.event_word
                val = struct.pack("I", next_event_word & 0xFFFFFFFF)
                self.send_mm.write(val)
                val = struct.pack("I", (next_event_word & 0xFFFFFFFF00000000) >> 32)
                self.send_mm.write(val)
                val = struct.pack("I", (dram_addr & 0xFFFFFFFF))  # lower int
                self.send_mm.write(val)
                val = struct.pack("I", ((dram_addr >> 32) & 0xFFFFFFFF))  # upper int
                self.send_mm.write(val)
                val = struct.pack("I", cont & 0xFFFFFFFF)
                self.send_mm.write(val)
                val = struct.pack("I", (cont & 0xFFFFFFFF00000000) >> 32)
                self.send_mm.write(val)
                val = struct.pack("I", size)
                self.send_mm.write(val)
                for value in ev_operands:
                    val = struct.pack("I", value & 0xFFFFFFFF)
                    self.send_mm.write(val)
                    val = struct.pack("I", (value & 0xFFFFFFFF00000000) >> 32)
                    self.send_mm.write(val)
                self.mm_offset = self.send_mm.tell()
        next_event.printOutStr(f"  Lane {self.network_id} sends", stage_trace)

    def do_sendr(self, action):
        """
        same as sendr_wcont
        """
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
        )

    def do_sendr3(self, action):
        """
        same as sendr3_wcont
        """
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        size = 3
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
            action.op3,
        )

    def do_sendmr(self, action):
        """
        same as sendr_dmlm
        """
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 0
        mode_1 = 0
        mode_2 = 1
        size = 1
        self.send_basic(
            event_word, dest, cont, action.op1, None, mode_0, mode_1, mode_2, 1, size
        )

    def do_sendmr2(self, action):
        """
        same as sendr2_dmlm
        """
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 0
        mode_1 = 0
        mode_2 = 1
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
        )

    def do_sendm(self, action):
        addr_mode = int(action.addr_mode)
        if addr_mode & 0b01 == 0:
            # load
            event_word = None  # self.curr_thread.rd_register(action.event)
            dest = self.curr_thread.rd_register(action.dst)
            cont = self.curr_thread.rd_register(action.cont)
            mode_0 = 0
            mode_1 = 0
            mode_2 = 0
            self.send_basic(
                event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
            )
        else:
            # store
            event_word = None
            dest = self.curr_thread.rd_register(action.dst)
            cont = self.curr_thread.rd_register(action.cont)
            mode_0 = 0
            mode_1 = 0
            mode_2 = 1
            self.send_basic(
                event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
            )

    def do_send4(self, action):
        if action.opcode == "sendmr" or action.opcode == "sendmr2":
            dest = self.curr_thread.rd_register(action.dst)
            event_word = None
        else:
            event_word = self.curr_thread.rd_register(action.event)
            dest = (event_word >> 32) & 0xFFFFFFFF
            # dest = action.dst
        cont = self.curr_thread.rd_register(action.cont)
        addr_mode = int(action.addr_mode)
        printd(
            "send4: ev:%x dest:%x, cont:%x, addr_mode:%d"
            % (event_word if event_word is not None else 0, dest, cont, addr_mode),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        """ Addr Modes
            Possible destinations
            Lane , DRAM, LM
            For Lane - Device ID
            DRAM, LM - Global Address
            Addr Mode - to distinguish between these
            Device ID - 0 - 63 lanes - Mode 0 (Device IDs beyond this on different UpStream Nodes potentially or other networked devices)
            LM - Mode 1
            DRAM - Mode 2, 3, 4, 5 [4 potential stream pointers]
        """
        mode_1 = addr_mode & 0x1
        mode_2 = 1  # always 1 for registers being sent
        if action.opcode == "sendmr" or action.opcode == "sendmr2":
            mode_0 = 0  # dest
        else:
            mode_0 = 1

        if action.op3 != "EMPTY":
            size = 3
        elif action.op2 != "EMPTY":
            size = 2
        else:
            size = 1

        # action.op1 can never be EMPTY
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
            action.op3,
        )

    def do_sendops(self, action):
        if action.opcode == "sendmops":
            dest = self.curr_thread.rd_register(action.dst)
            event_word = None
        else:
            event_word = self.curr_thread.rd_register(action.event)
            dest = (event_word >> 32) & 0xFFFFFFFF
            # dest = action.dst
        cont = self.curr_thread.rd_register(action.cont)
        addr_mode = int(action.addr_mode)
        printd(
            "send4: ev:%x dest:%x, cont:%x, addr_mode:%d"
            % (event_word if event_word is not None else 0, dest, cont, addr_mode),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        mode_1 = addr_mode & 0x1
        mode_2 = 1  # always 1 for registers being sent
        if action.opcode == "sendmops":
            mode_0 = 0  # dest
        else:
            mode_0 = 1
        if action.op2 != "EMPTY":
            size = action.op2

        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            True,
        )

    def do_send(self, action):
        if action.opcode == "send":
            event_word = self.curr_thread.rd_register(action.event)
        else:
            event_word = None
        if action.opcode == "sendm":
            dest = self.curr_thread.rd_register(action.dst)
        else:
            dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        addr_mode = int(action.addr_mode)

        if action.opcode == "sendm":
            mode_2 = addr_mode & 0x1  # $ldst
            mode_1 = (addr_mode & 0x2) >> 1  # cont
            mode_0 = 0  # dest
        else:
            mode_1 = addr_mode & 0x1
            mode_2 = 0  # don't care for n/w messages
            mode_0 = 1
        # Set s4 = 0
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
        )

    def do_send_wcont(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
        )

    def do_sendr_wcont(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
        )

    def do_sendr3_wcont(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        size = 3
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
            action.op3,
        )

    def do_sendops_wcont(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            True,
        )

    def do_send_wret(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = action.cont
        mode_0 = 1
        mode_1 = 1
        mode_2 = 0
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
        )

    def do_sendr_wret(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = action.cont
        mode_0 = 1
        mode_1 = 1
        mode_2 = 0
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
        )

    def do_sendr3_wret(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = action.cont
        mode_0 = 1
        mode_1 = 1
        mode_2 = 0
        size = 3
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
            action.op3,
        )

    def do_sendops_wret(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = action.cont
        mode_0 = 1
        mode_1 = 1
        mode_2 = 0
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            True,
        )

    def do_send_dmlm_ld(self, action):
        event_word = None  # self.curr_thread.rd_register(action.event)
        dest = self.curr_thread.rd_register(action.dst)
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 0
        mode_1 = 0
        mode_2 = 0
        self.send_basic(
            event_word, dest, cont, action.op1, action.op1, mode_0, mode_1, mode_2, 0
        )

    def do_send_dmlm_ld_wret(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = action.cont
        mode_0 = 0
        mode_1 = 1
        mode_2 = 0
        self.send_basic(
            event_word, dest, cont, action.op2, action.op1, mode_0, mode_1, mode_2, 0
        )

    def do_send_dmlm(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 0
        mode_1 = 0
        mode_2 = 1
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
        )

    def do_sendr_dmlm(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 0
        mode_1 = 0
        mode_2 = 1
        size = 1
        self.send_basic(
            event_word, dest, cont, action.op1, None, mode_0, mode_1, mode_2, 1, size
        )

    def do_sendr2_dmlm(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = self.curr_thread.rd_register(action.cont)
        mode_0 = 0
        mode_1 = 0
        mode_2 = 1
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
        )

    def do_send_dmlm_wret(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = action.cont
        mode_0 = 0
        mode_1 = 1
        mode_2 = 1
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
        )

    def do_sendr_dmlm_wret(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = action.cont
        mode_0 = 0
        mode_1 = 1
        mode_2 = 1
        size = 1
        self.send_basic(
            event_word, dest, cont, action.op1, None, mode_0, mode_1, mode_2, 1, size
        )

    def do_sendr2_dmlm_wret(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = action.cont
        mode_0 = 0
        mode_1 = 1
        mode_2 = 1
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
        )

    def do_sendops_dmlm_wret(self, action):
        event_word = None
        dest = self.curr_thread.rd_register(action.dst)
        cont = action.cont
        mode_0 = 0
        mode_1 = 1
        mode_2 = 1
        size = 2
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            True,
        )

    def do_send_reply(self, action):
        dest = self.curr_thread.continuation.network_id
        cont = 0x7FFFFFFFFFFFFFFF
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        event_word = self.curr_thread.continuation.event_word
        printd(
            "send_reply Thread State : %x" % event_word,
            stage_trace,
            self.metric.curTimeStamp(),
        )
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 0
        )

    def do_sendr_reply(self, action):
        dest = self.curr_thread.continuation.network_id
        cont = 0x7FFFFFFFFFFFFFFF
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        event_word = self.curr_thread.continuation.event_word
        size = 2
        printd(
            "send4_reply Thread State : %x" % event_word,
            stage_trace,
            self.metric.curTimeStamp(),
        )
        self.send_basic(
            event_word, dest, cont, action.op1, action.op2, mode_0, mode_1, mode_2, 1, size
        )

    def do_sendr3_reply(self, action):
        dest = self.curr_thread.continuation.network_id
        cont = 0x7FFFFFFFFFFFFFFF
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        event_word = self.curr_thread.continuation.event_word
        size = 3
        printd(
            "send4_reply Thread State : %x" % event_word,
            stage_trace,
            self.metric.curTimeStamp(),
        )
        self.send_basic(
            event_word,
            dest,
            cont,
            action.op1,
            action.op2,
            mode_0,
            mode_1,
            mode_2,
            1,
            size,
            False,
            action.op3
        )

    def do_send_any_wcont(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = self.curr_thread.rd_register(action.cont)
        op1 = self.curr_thread.rd_register(action.op1)
        mode_0 = 1
        mode_1 = 0
        mode_2 = 0
        reglist = action.reglist
        size = len(reglist)
        pact1 = Paction()
        pact2 = Paction()
        pact1.imm = 8
        pact1.dst = action.op1
        pact2.imm = 8
        pact2.src = action.op1
        pact2.dst = action.op1
        for i in range(size):
            pact1.src = reglist[i]
            self.do_mov_reg2lm(pact1)
            self.do_add_immediate(pact2)
        pact2.dst = action.op1
        pact2.imm = op1
        self.do_mov_imm2reg(pact2)
        op2 = size  # * 8
        self.send_basic(
            event_word, dest, cont, action.op1, op2, mode_0, mode_1, mode_2, 0
        )

    def do_send_any_wret(self, action):
        event_word = self.curr_thread.rd_register(action.event)
        dest = (event_word >> 32) & 0xFFFFFFFF
        cont = action.cont
        op1 = self.curr_thread.rd_register(action.op1)
        mode_0 = 1
        mode_1 = 1
        mode_2 = 0
        reglist = action.reglist
        size = len(reglist)
        pact1 = Paction()
        pact2 = Paction()
        pact1.imm = 8
        pact1.dst = action.op1
        pact2.imm = 8
        pact2.src = action.op1
        pact2.dst = action.op1
        for i in range(size):
            pact1.src = reglist[i]
            self.do_mov_reg2lm(pact1)
            self.do_add_immediate(pact2)
        pact2.dst = action.op1
        pact2.imm = op1
        self.do_mov_imm2reg(pact2)
        op2 = size  # * 8
        self.send_basic(
            event_word, dest, cont, action.op1, op2, mode_0, mode_1, mode_2, 0
        )

    def do_yield(self, action):
        # Potential Clean up code
        yield_exec = 1
        self.metric.ops_removed += self.curr_event.numOps()
        printd(
            "Clearing %d Operands on Yield" % (self.curr_event.numOps()),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        self.OpBuffer.clearOp(self.curr_event.numOps())
        ins_per_event = self.metric.total_acts - self.curr_event_sins
        cyc_per_event = self.metric.cycle - self.metric.curr_event_scyc

        if ins_per_event in self.metric.ins_per_event:
            self.metric.ins_per_event[ins_per_event] += 1
        else:
            self.metric.ins_per_event[ins_per_event] = 1
        if cyc_per_event in self.metric.cycles_per_event:
            self.metric.cycles_per_event[cyc_per_event] += 1
        else:
            self.metric.cycles_per_event[cyc_per_event] = 1
        if self.upproc.perf_log_internal_enable:
            self.metric.write_perf_log(
                0,
                self.lane_id,
                self.curr_thread.tid,
                self.curr_event.event_base,
                self.curr_event.event_label,
                set(
                    [
                        PerfLogPayload.UD_ACTION_STATS.value,
                        PerfLogPayload.UD_TRANS_STATS.value,
                        PerfLogPayload.UD_QUEUE_STATS.value,
                        PerfLogPayload.UD_LOCAL_MEM_STATS.value,
                        PerfLogPayload.UD_MEM_INTF_STATS.value,
                    ]
                ),
            )

        return yield_exec

    def do_yield_terminate(self, action):
        # Potential Clean up code
        yield_exec = 1
        yield_term = 1
        self.metric.ops_removed += self.curr_event.numOps()
        printd(
            "Clearing %d Operands on terminate" % (self.curr_event.numOps()),
            stage_trace,
            self.metric.curTimeStamp(),
        )
        self.OpBuffer.clearOp(self.curr_event.numOps())
        # Clear UDPR and threadstate and udpallocs
        self.tstable.remThreadfromTST(self.curr_thread.tid)
        ins_per_event = self.metric.total_acts - self.curr_event_sins
        cyc_per_event = self.metric.cycle - self.metric.curr_event_scyc
        if ins_per_event in self.metric.ins_per_event:
            self.metric.ins_per_event[ins_per_event] += 1
        else:
            self.metric.ins_per_event[ins_per_event] = 1
        if cyc_per_event in self.metric.cycles_per_event:
            self.metric.cycles_per_event[cyc_per_event] += 1
        else:
            self.metric.cycles_per_event[cyc_per_event] = 1
        if self.upproc.perf_log_internal_enable:
            self.metric.write_perf_log(
                0,
                self.lane_id,
                self.curr_thread.tid,
                self.curr_event.event_base,
                self.curr_event.event_label,
                set(
                    [
                        PerfLogPayload.UD_ACTION_STATS.value,
                        PerfLogPayload.UD_TRANS_STATS.value,
                        PerfLogPayload.UD_QUEUE_STATS.value,
                        PerfLogPayload.UD_LOCAL_MEM_STATS.value,
                        PerfLogPayload.UD_MEM_INTF_STATS.value,
                    ]
                ),
            )

        return yield_exec, yield_term

    def do_print(self, action):
        timestamp = str(self.metric.start_ticks + (self.metric.cycle * self.period))
        fmstr = timestamp + ": " + action.fmtstr
        fmtp = fmstr.split("%")
        numfmt = len(fmtp) - 1
        reglist = action.reglist
        regval = []
        for reg in reglist:
            regval.append(self.curr_thread.rd_register(reg))
        print(fmstr % (tuple(regval)), flush=True)

    def do_perflog(self, action):
        if not self.metric.perf_log_enable:
            return
        if action.mode == 0:
            self.metric.write_perf_log(
                self.network_id,
                self.ud_idx,
                self.lane_id,
                self.curr_thread.tid,
                self.curr_event.event_label,
                set(action.payload_list),
            )
        elif action.mode == 1:
            msg_reglist = []
            for reg in action.reglist:
                msg_reglist.append((reg, self.curr_thread.rd_register(reg)))
            self.metric.write_perf_log(
                self.network_id,
                self.ud_idx,
                self.lane_id,
                self.curr_thread.tid,
                self.curr_event.event_label,
                set(),
                action.msg_id,
                action.fmtstr,
                msg_reglist,
            )
        elif action.mode == 2:
            msg_reglist = []
            for reg in action.reglist:
                msg_reglist.append((reg, self.curr_thread.rd_register(reg)))
            self.metric.write_perf_log(
                self.network_id,
                self.ud_idx,
                self.lane_id,
                self.curr_thread.tid,
                self.curr_event.event_label,
                set(action.payload_list),
                action.msg_id,
                action.fmtstr,
                msg_reglist,
            )

    def do_user_ctr(self, action):
        if action.mode == 0:
            # increment mode
            self.metric.user_counters[action.ctr_num] += action.arg
        if action.mode == 1:
            # set abs mode
            self.metric.user_counters[action.ctr_num] = action.arg

    def do_lmmemcheck(self, action):
        """
        mode:
            'rr' - both start_addr and size are from registers
            'ri' - start_addr is from register, size is immediate
            'ii' - both start_addr and size are immediates
        """
        # pdb.set_trace()
        read_word = lambda addr: int(
            reduce(
                lambda acc, e: acc + e,
                map(
                    lambda offset: "{0:02x}".format(self.LM.read_byte(addr + offset)),
                    range(4),
                ),
                "",
            ),
            16,
        )

        mode = action.mode
        start_addr = 0
        size = 0

        # if mode == 'rr':
        #     start_addr = self.rd_register(action.start_addr)
        #     size = self.rd_register(action.size)
        # elif mode == 'ri':
        #     start_addr = self.rd_register(action.start_addr)
        #     size = int(action.size)
        # elif mode == 'ii':
        #     start_addr = int(action.start_addr)
        #     size = int(action.size)

        # print(">>>>> LM MEMCHECK START >>>>>")
        # # printing the values
        # str = ""
        # for i in range(size):
        #     if i > 0 and i % 16 == 0:
        #         print(str)
        #         str = ""
        #     val = self.LM.read_byte(start_addr + i)
        #     str += "{0:02x} ".format(val)
        # if len(str) > 0:
        #     print(str)
        #     str = ""
        # print("<<<<< LM MEMCHECK END <<<<<")

        print(">>>>>>>>>>>>>>>>>>>> LM Heap Blocks >>>>>>>>>>>>>>>>>>>>")
        heap = []
        address = int(action.start_addr)

        heap_init_word = read_word(address)
        if heap_init_word == 0:
            print("Uninitialized heap...")

        while heap_init_word and address < (
            (self.curr_thread.rd_register("LID") << 16) + 65536
        ):
            header = read_word(address)
            size = header >> 1
            allocation_flag = header & 1
            heap.append(f"({address}, {size}, {allocation_flag})")
            assert size > 0
            address += size

        if mode == "ii":
            allocation_address, allocation_success = self.curr_thread.rd_register(
                "X8"
            ), self.curr_thread.rd_register("X9")
            print(
                f"Heap ({allocation_address}, {allocation_success}) --> ",
                ";".join(heap),
            )
        elif mode == "rr":
            deallocation_address = self.curr_thread.rd_register("X8")
            print(
                f"Heap (Free, {deallocation_address}, {deallocation_address - 4}) --> ",
                ";".join(heap),
            )

        print("<<<<<<<<<<<<<<<<<<<<<<<<<<< LM Heap Blocks <<<<<<<<<<<<<<<<<<<<<<<<<<<<")

    def do_fp_add(self, action):
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        res = src + rt
        printd(
            "Lane %s do_fp_add - src: %s(%d), rt: %s(%d), dst: %s(%d)"
            % (self.lane_id, action.src, src, action.rt, rt, action.dst, res),
            stage_trace,
        )
        self.curr_thread.wr_register(action.dst, res)

    def do_fp_div(self, action):
        src = (self.curr_thread.rd_register(action.src) + 0.0) / (1 << 20)
        rt = self.curr_thread.rd_register(action.rt)
        res = src / rt
        res = round(res * (1 << 20))
        printd(
            "Lane %s do_fp_div - src: %s(%d), rt: %s(%s), dst: %s(%d)"
            % (
                self.lane_id,
                action.src,
                self.curr_thread.rd_register(action.src),
                action.rt,
                rt,
                action.dst,
                res,
            ),
            stage_trace,
        )
        self.curr_thread.wr_register(action.dst, res)

    def do_fmadd(self, action):
        self.curr_thread.SBCR_FSCR = self.curr_thread.SBCR_FSCR & 0x07FFFFFFFFFFFFFF
        precision = action.precision
        rmode = self.curr_thread.rmode
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        dst = self.curr_thread.rd_register(action.dst)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":     #gmpy2.precision = 53
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            s = struct.pack("<Q", rt)
            rt = struct.unpack("<d", s)[0]
            s = struct.pack("<Q", dst)
            dst = struct.unpack("<d", s)[0]
            gmpy2.get_context().precision = 53
            res = gmpy2.mul(src, rt)
            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
            res = gmpy2.add(res, dst)
            printd(
                f"  do_fmadd.fp64 - mask: {masks} src: {src} rt: {rt} dst: {dst} result: {res}",
                stage_trace,
            )
            # convert from double to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]
            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
        elif precision == "32":  # "FP32":
            gmpy2.get_context().precision = 24
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    rt = (rt & switch[i]) >> shiftval[i]
                    dst = (dst & switch[i]) >> shiftval[i]
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", dst)
                    dst = struct.unpack("<f", s)[0]
                    res_var = gmpy2.mul(src, rt)
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res_var = gmpy2.add(res_var, dst)
                    printd(
                        f"  do_madd.fp32 - mask: {masks} src: {src} rt: {rt} dst: {dst} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    src = (
                        (src & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    rt = (
                        (rt & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    dst = (
                        (dst & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", dst)
                    dst = struct.unpack("<f", s)[0]
                    res_var = gmpy2.mul(src, rt)
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res_var = gmpy2.add(res_var, dst)
                    printd(
                        f"  do_madd.bf16 - mask: {masks} src: {src} rt: {rt} dst: {dst} result: {res_var}",
                        stage_trace,
                    )
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    res_var = (
                        res_var >> 16
                    ) & 0x000000000000FFFF  # >> 16 converts it from fp32 to bf16
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_fadd(self, action):
        self.curr_thread.SBCR_FSCR = self.curr_thread.SBCR_FSCR & 0x07FFFFFFFFFFFFFF
        precision = action.precision
        rmode = self.curr_thread.rmode
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":     #gmpy2.precision = 53
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            s = struct.pack("<Q", rt)
            rt = struct.unpack("<d", s)[0]
            gmpy2.get_context().precision = 53
            res = gmpy2.add(src, rt)
            printd(
                f"  do_fadd.fp64 - mask: {masks} src: {src} rt: {rt} result: {res}",
                stage_trace,
            )
            # convert from double to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]
            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
        elif precision == "32":  # "FP32":
            gmpy2.get_context().precision = 24
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    rt = (rt & switch[i]) >> shiftval[i]
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.add(src, rt)
                    printd(
                        f"  do_add.fp32 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    src = (
                        (src & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    rt = (
                        (rt & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.add(src, rt)
                    printd(
                        f"  do_add.bf16 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    res_var = (
                        res_var >> 16
                    ) & 0x000000000000FFFF  # >> 16 converts it from fp32 to bf16
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        # print(res)
        self.curr_thread.wr_register(action.dst, res)

    def do_fsub(self, action):
        self.curr_thread.SBCR_FSCR = self.curr_thread.SBCR_FSCR & 0x07FFFFFFFFFFFFFF
        precision = action.precision
        rmode = self.curr_thread.rmode
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":     #gmpy2.precision = 53
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            s = struct.pack("<Q", rt)
            rt = struct.unpack("<d", s)[0]
            gmpy2.get_context().precision = 53
            res = gmpy2.sub(src, rt)
            printd(
                f"  do_fsub.fp64 - mask: {masks} src: {src} rt: {rt} result: {res}",
                stage_trace,
            )
            # convert from double to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]
            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
        elif precision == "32":  # "FP32":
            gmpy2.get_context().precision = 24
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    rt = (rt & switch[i]) >> shiftval[i]
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.sub(src, rt)
                    printd(
                        f"  do_sub.fp32 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    src = (
                        (src & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    rt = (
                        (rt & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.sub(src, rt)
                    printd(
                        f"  do_sub.bf16 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    res_var = (
                        res_var >> 16
                    ) & 0x000000000000FFFF  # >> 16 converts it from fp32 to bf16
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_fmul(self, action):
        self.curr_thread.SBCR_FSCR = self.curr_thread.SBCR_FSCR & 0x07FFFFFFFFFFFFFF
        precision = action.precision
        rmode = self.curr_thread.rmode
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":     #gmpy2.precision = 53
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            s = struct.pack("<Q", rt)
            rt = struct.unpack("<d", s)[0]
            gmpy2.get_context().precision = 53
            res = gmpy2.mul(src, rt)
            printd(
                f"  do_fmul.fp64 - mask: {masks} src: {src} rt: {rt} result: {res}",
                stage_trace,
            )
            # convert from double to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]
            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
        elif precision == "32":  # "FP32":
            gmpy2.get_context().precision = 24
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    rt = (rt & switch[i]) >> shiftval[i]
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.mul(src, rt)
                    printd(
                        f"  do_mul.fp32 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    src = (
                        (src & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    rt = (
                        (rt & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.mul(src, rt)
                    printd(
                        f"  do_mul.bf16 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    res_var = (
                        res_var >> 16
                    ) & 0x000000000000FFFF  # >> 16 converts it from fp32 to bf16
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_fdiv(self, action):
        self.curr_thread.SBCR_FSCR = self.curr_thread.SBCR_FSCR & 0x07FFFFFFFFFFFFFF
        precision = action.precision
        rmode = self.curr_thread.rmode
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":     #gmpy2.precision = 53
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            s = struct.pack("<Q", rt)
            rt = struct.unpack("<d", s)[0]
            gmpy2.get_context().precision = 53
            res = gmpy2.div(src, rt)
            printd(
                f"  do_fdiv.fp64 - mask: {masks} src: {src} rt: {rt} result: {res}",
                stage_trace,
            )
            # convert from double to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]

            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
        elif precision == "32":  # "FP32":
            gmpy2.get_context().precision = 24
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    rt = (rt & switch[i]) >> shiftval[i]
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.div(src, rt)
                    printd(
                        f"  do_div.fp32 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    src = (
                        (src & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    rt = (
                        (rt & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    s = struct.pack("<l", rt)
                    rt = struct.unpack("<f", s)[0]
                    res_var = gmpy2.div(src, rt)
                    printd(
                        f"  do_div.bf16 - mask: {masks} src: {src} rt: {rt} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    res_var = (
                        res_var >> 16
                    ) & 0x000000000000FFFF  # >> 16 converts it from fp32 to bf16
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        # print(res)
        self.curr_thread.wr_register(action.dst, res)

    def do_fsqrt(self, action):
        self.curr_thread.SBCR_FSCR = self.curr_thread.SBCR_FSCR & 0x07FFFFFFFFFFFFFF
        precision = action.precision
        rmode = self.curr_thread.rmode
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":     #gmpy2.precision = 53
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            gmpy2.get_context().precision = 53
            res = gmpy2.sqrt(src)
            printd(
                f"  do_sqrt.fp64 - mask: {masks} src: {src} result: {res}", stage_trace
            )
            # convert from double to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]
            # set flags
            if gmpy2.get_context().invalid == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x8000000000000000
                )
            if gmpy2.get_context().divzero == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x4000000000000000
                )
            if gmpy2.get_context().overflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x2000000000000000
                )
            if gmpy2.get_context().underflow == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x1000000000000000
                )
            if gmpy2.get_context().inexact == True:
                self.curr_thread.SBCR_FSCR = (
                    self.curr_thread.SBCR_FSCR | 0x0800000000000000
                )
        elif precision == "32":  # "FP32":
            gmpy2.get_context().precision = 24
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    res_var = gmpy2.sqrt(src)
                    printd(
                        f"  do_sqrt.fp32 - mask: {masks} src: {src} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    src = (
                        (src & switch[i]) >> shiftval[i]
                    ) << 16  # << 16 converts it to fp32 to make sure struct pack unpack works correctly
                    # convert back to float
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    res_var = gmpy2.sqrt(src)
                    printd(
                        f"  do_sqrt.bf16 - mask: {masks} src: {src} result: {res_var}",
                        stage_trace,
                    )
                    # convert from float to int
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                    res_var = (
                        res_var >> 16
                    ) & 0x000000000000FFFF  # >> 16 converts it from fp32 to bf16
                    # set flags
                    if gmpy2.get_context().invalid == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x8000000000000000
                        )
                    if gmpy2.get_context().divzero == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x4000000000000000
                        )
                    if gmpy2.get_context().overflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x2000000000000000
                        )
                    if gmpy2.get_context().underflow == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x1000000000000000
                        )
                    if gmpy2.get_context().inexact == True:
                        self.curr_thread.SBCR_FSCR = (
                            self.curr_thread.SBCR_FSCR | 0x0800000000000000
                        )
                    res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_fexp(self, action):
        print("fexp not implemented yet!")

    def do_fcnvt_i2f(self, action):
        precision = action.precision
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":
            res = float(src)
            printd(f"  fcnvt_i2f - src: {src} result: {res}", stage_trace)
            #   convert from float to int
            s = struct.pack("<d", res)
            res = struct.unpack("<q", s)[0]
        elif precision == "32":  # "FP32":
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    res_var = float((src & switch[i]) >> shiftval[i])
                    s = struct.pack("<f", res_var)
                    res_var = struct.unpack("<l", s)[0]
                res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_fcnvt_f2i(self, action):
        precision = action.precision
        if action.opcode[0] == "f":
            mask = 0b0001
        else:
            mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "64":  # "FP64":
            # convert back to double
            s = struct.pack("<Q", src)
            src = struct.unpack("<d", s)[0]
            res = int(math.floor(src))
        elif precision == "32":  # "FP32":
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    src = (src & switch[i]) >> shiftval[i]
                    s = struct.pack("<l", src)
                    src = struct.unpack("<f", s)[0]
                    res_var = int(math.floor(src))
                res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_vfill(self, action):
        precision = action.precision
        if precision == "64":  # fp64
            immidiate = float(action.imm)
            #   convert from float to int
            s = struct.pack("<d", immidiate)
            immidiate = struct.unpack("<q", s)[0]
            res = immidiate
        elif precision == "32":  # fp32
            immidiate = float(action.imm)
            s = struct.pack("<f", immidiate)
            immidiate = struct.unpack("<l", s)[0]
            res = ((immidiate & 0xFFFFFFFF) << 32) | (immidiate & 0xFFFFFFFF)
        elif precision == "b16":  # bf16
            immidiate = float(action.imm)
            s = struct.pack("<f", immidiate)
            immidiate = struct.unpack("<l", s)[0]
            immidiate = (
                immidiate >> 16
            ) & 0x000000000000FFFF  # >>16 to convert from fp32 to bf16
            res = (
                ((immidiate & 0xFFFF) << 48)
                | ((immidiate & 0xFFFF) << 32)
                | ((immidiate & 0xFFFF) << 16)
                | (immidiate & 0xFFFF)
            )
        elif precision == "i32":  # i32
            res = ((action.imm & 0xFFFFFFFF) << 32) | (action.imm & 0xFFFFFFFF)
        self.curr_thread.wr_register(action.dst, res)

    def do_vgt(self, action):
        precision = action.precision
        mask = int(action.mask)
        src = self.curr_thread.rd_register(action.src)
        rt = self.curr_thread.rd_register(action.rt)
        masks = [mask % 2, (mask >> 1) % 2, (mask >> 2) % 2, (mask >> 3) % 2]
        if precision == "i32":  # "INT32": ?? How is this correct?
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    if ((src & switch[i]) >> shiftval[i]) > (
                        (rt & switch[i]) >> shiftval[i]
                    ):
                        res_var = 1
                    else:
                        res_var = 0
                res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "32":  # "FP32":
            switch = {0: 0x00000000FFFFFFFF, 1: 0xFFFFFFFF00000000}
            shiftval = {0: 0, 1: 32}
            res = 0
            for i in range(2):
                if masks[i] == 1:
                    if ((src & switch[i]) >> shiftval[i]) > (
                        (rt & switch[i]) >> shiftval[i]
                    ):
                        res_var = 1
                    else:
                        res_var = 0
                res = res | ((res_var << shiftval[i]) & switch[i])
        elif precision == "b16":  # "BFP16":
            gmpy2.get_context().precision = 8
            switch = {
                0: 0x000000000000FFFF,
                1: 0x00000000FFFF0000,
                2: 0x0000FFFF00000000,
                3: 0xFFFF000000000000,
            }
            shiftval = {0: 0, 1: 16, 2: 32, 3: 48}
            res = 0
            for i in range(4):
                if masks[i] == 1:
                    if ((src & switch[i]) >> shiftval[i]) > (
                        (rt & switch[i]) >> shiftval[i]
                    ):
                        res_var = 1
                    else:
                        res_var = 0
                res = res | ((res_var << shiftval[i]) & switch[i])

        self.curr_thread.wr_register(action.dst, res)

    def do_insert_translation(self, action):
        vbase = self.curr_thread.rd_register(action.op1)
        pbase = self.curr_thread.rd_register(action.op2)
        size = self.curr_thread.rd_register(action.op3)
        mask = self.curr_thread.rd_register(action.op4)
        if int(action.mode) == 0:
            self.mmu.insert_local_translation(vbase, size, pbase, action.size)
        else:
            self.mmu.insert_global_translation(vbase, size, mask, pbase, action.size)
